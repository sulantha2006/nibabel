<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &#8212; NiBabel 2.1.1dev documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.1.1dev documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="spm2analyze" href="nibabel.spm2analyze.html" />
    <link rel="prev" title="nibabel" href="nibabel.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.spm2analyze.html" title="spm2analyze"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.html" title="nibabel"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">analyze</span></code></a><ul>
<li><a class="reference internal" href="#the-analyze-header-format">The Analyze header format</a><ul>
<li><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analyzeheader"><code class="docutils literal"><span class="pre">AnalyzeHeader</span></code></a></li>
<li><a class="reference internal" href="#analyzeimage"><code class="docutils literal"><span class="pre">AnalyzeImage</span></code></a></li>
<li><a class="reference internal" href="#load">load</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">nibabel</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.spm2analyze.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">spm2analyze</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.analyze.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.analyze">
<span id="analyze"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">analyze</span></code><a class="headerlink" href="#module-nibabel.analyze" title="Permalink to this headline">¶</a></h1>
<p>Read / write access to the basic Mayo Analyze format</p>
<div class="section" id="the-analyze-header-format">
<h2>The Analyze header format<a class="headerlink" href="#the-analyze-header-format" title="Permalink to this headline">¶</a></h2>
<p>This is a binary header format and inherits from <code class="docutils literal"><span class="pre">WrapStruct</span></code></p>
<p>Apart from the attributes and methods of WrapStruct:</p>
<p>Class attributes are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">default_x_flip</span>
</pre></div>
</div>
<p>with methods:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">get</span><span class="o">/</span><span class="n">set_data_shape</span>
<span class="o">.</span><span class="n">get</span><span class="o">/</span><span class="n">set_data_dtype</span>
<span class="o">.</span><span class="n">get</span><span class="o">/</span><span class="n">set_zooms</span>
<span class="o">.</span><span class="n">get</span><span class="o">/</span><span class="n">set_data_offset</span>
<span class="o">.</span><span class="n">get_base_affine</span><span class="p">()</span>
<span class="o">.</span><span class="n">get_best_affine</span><span class="p">()</span>
<span class="o">.</span><span class="n">data_to_fileobj</span>
<span class="o">.</span><span class="n">data_from_fileobj</span>
</pre></div>
</div>
<p>and class methods:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">from_header</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
</pre></div>
</div>
<p>More sophisticated headers can add more methods and attributes.</p>
<div class="section" id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h3>
<p>This - basic - analyze header cannot encode full affines (only
diagonal affines), and cannot do integer scaling.</p>
<p>The inability to store affines means that we have to guess what orientation the
image has.  Most Analyze images are stored on disk in (fastest-changing to
slowest-changing) R-&gt;L, P-&gt;A and I-&gt;S order.  That is, the first voxel is the
rightmost, most posterior and most inferior voxel location in the image, and
the next voxel is one voxel towards the left of the image.</p>
<p>Most people refer to this disk storage format as &#8216;radiological&#8217;, on the basis
that, if you load up the data as an array <code class="docutils literal"><span class="pre">img_arr</span></code> where the first axis is
the fastest changing, then take a slice in the I-&gt;S axis - <code class="docutils literal"><span class="pre">img_arr[:,:,10]</span></code>
- then the right part of the brain will be on the left of your displayed slice.
Radiologists like looking at images where the left of the brain is on the right
side of the image.</p>
<p>Conversely, if the image has the voxels stored with the left voxels first -
L-&gt;R, P-&gt;A, I-&gt;S, then this would be &#8216;neurological&#8217; format.  Neurologists like
looking at images where the left side of the brain is on the left of the image.</p>
<p>When we are guessing at an affine for Analyze, this translates to the problem
of whether the affine should consider proceeding within the data down an X line
as being from left to right, or right to left.</p>
<p>By default we assume that the image is stored in R-&gt;L format.  We encode this
choice in the <code class="docutils literal"><span class="pre">default_x_flip</span></code> flag that can be True or False.  True means
assume radiological.</p>
<p>If the image is 3D, and the X, Y and Z zooms are x, y, and z, then:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">default_x_flip</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">::</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>In our implementation, there is no way of saving this assumed flip into the
header.  One way of doing this, that we have not used, is to allow negative
zooms, in particular, negative X zooms.  We did not do this because the image
can be loaded with and without a default flip, so the saved zoom will not
constrain the affine.</p>
</div>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.analyze.AnalyzeHeader" title="nibabel.analyze.AnalyzeHeader"><code class="xref py py-obj docutils literal"><span class="pre">AnalyzeHeader</span></code></a>([binaryblock,&nbsp;endianness,&nbsp;check])</td>
<td>Class for basic analyze header</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.analyze.AnalyzeImage" title="nibabel.analyze.AnalyzeImage"><code class="xref py py-obj docutils literal"><span class="pre">AnalyzeImage</span></code></a>(dataobj,&nbsp;affine[,&nbsp;header,&nbsp;...])</td>
<td>Class for basic Analyze format image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.analyze.load" title="nibabel.analyze.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a></td>
<td>class method to create image from filename <cite>filename</cite></td>
</tr>
</tbody>
</table>
<div class="section" id="analyzeheader">
<h2><a class="reference internal" href="#nibabel.analyze.AnalyzeHeader" title="nibabel.analyze.AnalyzeHeader"><code class="xref py py-class docutils literal"><span class="pre">AnalyzeHeader</span></code></a><a class="headerlink" href="#analyzeheader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.analyze.AnalyzeHeader">
<em class="property">class </em><code class="descclassname">nibabel.analyze.</code><code class="descname">AnalyzeHeader</code><span class="sig-paren">(</span><em>binaryblock=None</em>, <em>endianness=None</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.wrapstruct.html#nibabel.wrapstruct.LabeledWrapStruct" title="nibabel.wrapstruct.LabeledWrapStruct"><code class="xref py py-class docutils literal"><span class="pre">nibabel.wrapstruct.LabeledWrapStruct</span></code></a></p>
<p>Class for basic analyze header</p>
<p>Implements zoom-only setting of affine transform, and no image
scaling</p>
<p>Initialize header from binary data block</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>binaryblock</strong> : {None, string} optional</p>
<blockquote>
<div><p>binary block to set into header.  By default, None, in
which case we insert the default empty header block</p>
</div></blockquote>
<p><strong>endianness</strong> : {None, &#8216;&lt;&#8217;,&#8217;&gt;&#8217;, other endian code} string, optional</p>
<blockquote>
<div><p>endianness of the binaryblock.  If None, guess endianness
from the data.</p>
</div></blockquote>
<p><strong>check</strong> : bool, optional</p>
<blockquote class="last">
<div><p>Whether to check content of header in initialization.
Default is True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span> <span class="c1"># an empty header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># now with some content</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>We can set the binary block directly via this initialization.
Here we get it from the header we have just made</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binblock2</span> <span class="o">=</span> <span class="n">hdr1</span><span class="o">.</span><span class="n">binaryblock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr2</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">(</span><span class="n">binblock2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr2</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>Empty headers are native endian by default</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr2</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can pass valid opposite endian headers with the
<code class="docutils literal"><span class="pre">endianness</span></code> parameter. Even empty headers can have
endianness</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr3</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">(</span><span class="n">endianness</span><span class="o">=</span><span class="n">swapped_code</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr3</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you do not pass an endianness, and you pass some data, we
will try to guess from the passed data.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binblock3</span> <span class="o">=</span> <span class="n">hdr3</span><span class="o">.</span><span class="n">binaryblock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr4</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">(</span><span class="n">binblock3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr4</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>binaryblock=None</em>, <em>endianness=None</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize header from binary data block</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>binaryblock</strong> : {None, string} optional</p>
<blockquote>
<div><p>binary block to set into header.  By default, None, in
which case we insert the default empty header block</p>
</div></blockquote>
<p><strong>endianness</strong> : {None, &#8216;&lt;&#8217;,&#8217;&gt;&#8217;, other endian code} string, optional</p>
<blockquote>
<div><p>endianness of the binaryblock.  If None, guess endianness
from the data.</p>
</div></blockquote>
<p><strong>check</strong> : bool, optional</p>
<blockquote class="last">
<div><p>Whether to check content of header in initialization.
Default is True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span> <span class="c1"># an empty header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># now with some content</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr1</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>We can set the binary block directly via this initialization.
Here we get it from the header we have just made</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binblock2</span> <span class="o">=</span> <span class="n">hdr1</span><span class="o">.</span><span class="n">binaryblock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr2</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">(</span><span class="n">binblock2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr2</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>Empty headers are native endian by default</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr2</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can pass valid opposite endian headers with the
<code class="docutils literal"><span class="pre">endianness</span></code> parameter. Even empty headers can have
endianness</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr3</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">(</span><span class="n">endianness</span><span class="o">=</span><span class="n">swapped_code</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr3</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you do not pass an endianness, and you pass some data, we
will try to guess from the passed data.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binblock3</span> <span class="o">=</span> <span class="n">hdr3</span><span class="o">.</span><span class="n">binaryblock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr4</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">(</span><span class="n">binblock3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr4</span><span class="o">.</span><span class="n">endianness</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.as_analyze_map">
<code class="descname">as_analyze_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.as_analyze_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return header as mapping for conversion to Analyze types</p>
<p>Collect data from custom header type to fill in fields for Analyze and
derived header types (such as Nifti1 and Nifti2).</p>
<p>When Analyze types convert another header type to their own type, they
call this this method to check if there are other Analyze / Nifti
fields that the source header would like to set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>analyze_map</strong> : mapping</p>
<blockquote class="last">
<div><p>Object that can be used as a mapping thus:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">analyze_map</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">analyze_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">key</span></code> is the name of a field that can be set in an Analyze
header type, such as Nifti1, and <code class="docutils literal"><span class="pre">value</span></code> is a value for the
field.  For example, <cite>analyze_map</cite> might be a something like
<code class="docutils literal"><span class="pre">dict(regular='y',</span> <span class="pre">slice_duration=0.3)</span></code> where <code class="docutils literal"><span class="pre">regular</span></code> is a
field present in both Analyze and Nifti1, and <code class="docutils literal"><span class="pre">slice_duration</span></code> is
a field restricted to Nifti1 and Nifti2.  If a particular Analyze
header type does not recognize the field name, it will throw away
the value without error.  See <code class="xref py py-meth docutils literal"><span class="pre">Analyze.from_header()</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>You can also return a Nifti header with the relevant fields set.</p>
<p>Your header still needs methods <code class="docutils literal"><span class="pre">get_data_dtype</span></code>, <code class="docutils literal"><span class="pre">get_data_shape</span></code>
and <code class="docutils literal"><span class="pre">get_zooms</span></code>, for the conversion, and these get called <em>after</em>
using the analyze map, so the methods will override values set in the
map.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.data_from_fileobj">
<code class="descname">data_from_fileobj</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.data_from_fileobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Read scaled data array from <cite>fileobj</cite></p>
<p>Use this routine to get the scaled image data from an image file
<cite>fileobj</cite>, given a header <cite>self</cite>.  &#8220;Scaled&#8221; means, with any header
scaling factors applied to the raw data in the file.  Use
<cite>raw_data_from_fileobj</cite> to get the raw data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : file-like</p>
<blockquote>
<div><p>Must be open, and implement <code class="docutils literal"><span class="pre">read</span></code> and <code class="docutils literal"><span class="pre">seek</span></code> methods</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : ndarray</p>
<blockquote class="last">
<div><p>scaled data array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the header to get any scale or intercept values to apply to the
data.  Raw Analyze files don&#8217;t have scale factors or intercepts, but
this routine also works with formats based on Analyze, that do have
scaling, such as SPM analyze formats and NIfTI.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.data_to_fileobj">
<code class="descname">data_to_fileobj</code><span class="sig-paren">(</span><em>data</em>, <em>fileobj</em>, <em>rescale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.data_to_fileobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Write <cite>data</cite> to <cite>fileobj</cite>, maybe rescaling data, modifying <cite>self</cite></p>
<p>In writing the data, we match the header to the written data, by
setting the header scaling factors, iff <cite>rescale</cite> is True.  Thus we
modify <cite>self</cite> in the process of writing the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>data to write; should match header defined shape</p>
</div></blockquote>
<p><strong>fileobj</strong> : file-like object</p>
<blockquote>
<div><p>Object with file interface, implementing <code class="docutils literal"><span class="pre">write</span></code> and
<code class="docutils literal"><span class="pre">seek</span></code></p>
</div></blockquote>
<p><strong>rescale</strong> : {True, False}, optional</p>
<blockquote class="last">
<div><p>Whether to try and rescale data to match output dtype specified by
header. If True and scaling needed and header cannot scale, then
raise <code class="docutils literal"><span class="pre">HeaderTypeError</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nibabel.analyze</span> <span class="k">import</span> <span class="n">AnalyzeHeader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_io</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">data_to_fileobj</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str_io</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">str_io</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeHeader.default_structarr">
<em class="property">classmethod </em><code class="descname">default_structarr</code><span class="sig-paren">(</span><em>klass</em>, <em>endianness=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.default_structarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return header data for empty header with given endianness</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeHeader.default_x_flip">
<code class="descname">default_x_flip</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.default_x_flip" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeHeader.from_header">
<em class="property">classmethod </em><code class="descname">from_header</code><span class="sig-paren">(</span><em>klass</em>, <em>header=None</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.from_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method to create header from another header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>header</strong> : <code class="docutils literal"><span class="pre">Header</span></code> instance or mapping</p>
<blockquote>
<div><p>a header of this class, or another class of header for
conversion to this type</p>
</div></blockquote>
<p><strong>check</strong> : {True, False}</p>
<blockquote>
<div><p>whether to check header for integrity</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hdr</strong> : header instance</p>
<blockquote class="last">
<div><p>fresh header instance of our own class</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_base_affine">
<code class="descname">get_base_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_base_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get affine from basic (shared) header fields</p>
<p>Note that we get the translations from the center of the
image.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_zooms</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">default_x_flip</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_base_affine</span><span class="p">()</span> <span class="c1"># from center of image</span>
<span class="go">array([[-3.,  0.,  0.,  3.],</span>
<span class="go">       [ 0.,  2.,  0., -4.],</span>
<span class="go">       [ 0.,  0.,  1., -3.],</span>
<span class="go">       [ 0.,  0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_best_affine">
<code class="descname">get_best_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_best_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get affine from basic (shared) header fields</p>
<p>Note that we get the translations from the center of the
image.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_zooms</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">default_x_flip</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_base_affine</span><span class="p">()</span> <span class="c1"># from center of image</span>
<span class="go">array([[-3.,  0.,  0.,  3.],</span>
<span class="go">       [ 0.,  2.,  0., -4.],</span>
<span class="go">       [ 0.,  0.,  1., -3.],</span>
<span class="go">       [ 0.,  0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_data_dtype">
<code class="descname">get_data_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_data_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Get numpy dtype for data</p>
<p>For examples see <code class="docutils literal"><span class="pre">set_data_dtype</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_data_offset">
<code class="descname">get_data_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_data_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return offset into data file to read data</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_offset</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;vox_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_offset</span><span class="p">()</span>
<span class="go">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_data_shape">
<code class="descname">get_data_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_data_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get shape of data</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>Expanding number of dimensions gets default zooms</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()</span>
<span class="go">(1.0, 1.0, 1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_slope_inter">
<code class="descname">get_slope_inter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_slope_inter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get scalefactor and intercept</p>
<p>These are not implemented for basic Analyze</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.get_zooms">
<code class="descname">get_zooms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.get_zooms" title="Permalink to this definition">¶</a></dt>
<dd><p>Get zooms from header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>z</strong> : tuple</p>
<blockquote class="last">
<div><p>tuple of header zoom values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()</span>
<span class="go">(1.0,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()</span>
<span class="go">(1.0, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_zooms</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()</span>
<span class="go">(3.0, 4.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeHeader.guessed_endian">
<em class="property">classmethod </em><code class="descname">guessed_endian</code><span class="sig-paren">(</span><em>klass</em>, <em>hdr</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.guessed_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess intended endianness from mapping-like <code class="docutils literal"><span class="pre">hdr</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hdr</strong> : mapping-like</p>
<blockquote>
<div><p>hdr for which to guess endianness</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>endianness</strong> : {&#8216;&lt;&#8217;, &#8216;&gt;&#8217;}</p>
<blockquote class="last">
<div><p>Guessed endianness of header</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Zeros header, no information, guess native</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">header_dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A valid native header is guessed native</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">.</span><span class="n">structarr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And, when swapped, is guessed as swapped</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sw_hdr_data</span> <span class="o">=</span> <span class="n">hdr_data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="n">swapped_code</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">sw_hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The algorithm is as follows:</p>
<p>First, look at the first value in the <code class="docutils literal"><span class="pre">dim</span></code> field; this
should be between 0 and 7.  If it is between 1 and 7, then
this must be a native endian header.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">header_dtype</span><span class="p">)</span> <span class="c1"># blank binary data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the first <code class="docutils literal"><span class="pre">dim</span></code> value is zeros, we need a tie breaker.
In that case we check the <code class="docutils literal"><span class="pre">sizeof_hdr</span></code> field.  This should
be 348.  If it looks like the byteswapped value of 348,
assumed swapped.  Otherwise assume native.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">header_dtype</span><span class="p">)</span> <span class="c1"># blank binary data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;sizeof_hdr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1543569408</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;sizeof_hdr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is overridden by the <code class="docutils literal"><span class="pre">dim[0]</span></code> value though:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;sizeof_hdr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1543569408</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr_data</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnalyzeHeader</span><span class="o">.</span><span class="n">guessed_endian</span><span class="p">(</span><span class="n">hdr_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeHeader.has_data_intercept">
<code class="descname">has_data_intercept</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.has_data_intercept" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeHeader.has_data_slope">
<code class="descname">has_data_slope</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.has_data_slope" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeHeader.may_contain_header">
<em class="property">classmethod </em><code class="descname">may_contain_header</code><span class="sig-paren">(</span><em>klass</em>, <em>binaryblock</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.may_contain_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.raw_data_from_fileobj">
<code class="descname">raw_data_from_fileobj</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.raw_data_from_fileobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Read unscaled data array from <cite>fileobj</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : file-like</p>
<blockquote>
<div><p>Must be open, and implement <code class="docutils literal"><span class="pre">read</span></code> and <code class="docutils literal"><span class="pre">seek</span></code> methods</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : ndarray</p>
<blockquote class="last">
<div><p>unscaled data array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.set_data_dtype">
<code class="descname">set_data_dtype</code><span class="sig-paren">(</span><em>datatype</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.set_data_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set numpy dtype for data from code or dtype or type</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">AnalyzeHeader</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_dtype</span><span class="p">()</span>
<span class="go">dtype(&#39;uint8&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_dtype</span><span class="p">()</span>
<span class="go">dtype(&#39;uint8&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="s1">&#39;implausible&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">HeaderDataError</span>: <span class="n">data dtype &quot;implausible&quot; not recognized</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">HeaderDataError</span>: <span class="n">data dtype &quot;none&quot; known but not supported</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">HeaderDataError</span>: <span class="n">data dtype &quot;&lt;type &#39;numpy.void&#39;&gt;&quot; known but not supported</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.set_data_offset">
<code class="descname">set_data_offset</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.set_data_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Set offset into data file to read data</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.set_data_shape">
<code class="descname">set_data_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.set_data_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Set shape of data</p>
<p>If <code class="docutils literal"><span class="pre">ndims</span> <span class="pre">==</span> <span class="pre">len(shape)</span></code> then we set zooms for dimensions higher than
<code class="docutils literal"><span class="pre">ndims</span></code> to 1.0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : sequence</p>
<blockquote class="last">
<div><p>sequence of integers specifying data array shape</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.set_slope_inter">
<code class="descname">set_slope_inter</code><span class="sig-paren">(</span><em>slope</em>, <em>inter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.set_slope_inter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set slope and / or intercept into header</p>
<p>Set slope and intercept for image data, such that, if the image
data is <code class="docutils literal"><span class="pre">arr</span></code>, then the scaled image data will be <code class="docutils literal"><span class="pre">(arr</span> <span class="pre">*</span>
<span class="pre">slope)</span> <span class="pre">+</span> <span class="pre">inter</span></code></p>
<p>In this case, for Analyze images, we can&#8217;t store the slope or the
intercept, so this method only checks that <cite>slope</cite> is None or NaN or
1.0, and that <cite>inter</cite> is None or NaN or 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>slope</strong> : None or float</p>
<blockquote>
<div><p>If float, value must be NaN or 1.0 or we raise a <code class="docutils literal"><span class="pre">HeaderTypeError</span></code></p>
</div></blockquote>
<p><strong>inter</strong> : None or float, optional</p>
<blockquote class="last">
<div><p>If float, value must be 0.0 or we raise a <code class="docutils literal"><span class="pre">HeaderTypeError</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeHeader.set_zooms">
<code class="descname">set_zooms</code><span class="sig-paren">(</span><em>zooms</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.set_zooms" title="Permalink to this definition">¶</a></dt>
<dd><p>Set zooms into header fields</p>
<p>See docstring for <code class="docutils literal"><span class="pre">get_zooms</span></code> for examples</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeHeader.sizeof_hdr">
<code class="descname">sizeof_hdr</code><em class="property"> = 348</em><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.sizeof_hdr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeHeader.template_dtype">
<code class="descname">template_dtype</code><em class="property"> = dtype([('sizeof_hdr', '&lt;i4'), ('data_type', 'S10'), ('db_name', 'S18'), ('extents', '&lt;i4'), ('session_error', '&lt;i2'), ('regular', 'S1'), ('hkey_un0', 'S1'), ('dim', '&lt;i2', (8,)), ('vox_units', 'S4'), ('cal_units', 'S8'), ('unused1', '&lt;i2'), ('datatype', '&lt;i2'), ('bitpix', '&lt;i2'), ('dim_un0', '&lt;i2'), ('pixdim', '&lt;f4', (8,)), ('vox_offset', '&lt;f4'), ('funused1', '&lt;f4'), ('funused2', '&lt;f4'), ('funused3', '&lt;f4'), ('cal_max', '&lt;f4'), ('cal_min', '&lt;f4'), ('compressed', '&lt;i4'), ('verified', '&lt;i4'), ('glmax', '&lt;i4'), ('glmin', '&lt;i4'), ('descrip', 'S80'), ('aux_file', 'S24'), ('orient', 'S1'), ('originator', 'S10'), ('generated', 'S10'), ('scannum', 'S10'), ('patient_id', 'S10'), ('exp_date', 'S10'), ('exp_time', 'S10'), ('hist_un0', 'S3'), ('views', '&lt;i4'), ('vols_added', '&lt;i4'), ('start_field', '&lt;i4'), ('field_skip', '&lt;i4'), ('omax', '&lt;i4'), ('omin', '&lt;i4'), ('smax', '&lt;i4'), ('smin', '&lt;i4')])</em><a class="headerlink" href="#nibabel.analyze.AnalyzeHeader.template_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="analyzeimage">
<h2><a class="reference internal" href="#nibabel.analyze.AnalyzeImage" title="nibabel.analyze.AnalyzeImage"><code class="xref py py-class docutils literal"><span class="pre">AnalyzeImage</span></code></a><a class="headerlink" href="#analyzeimage" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.analyze.AnalyzeImage">
<em class="property">class </em><code class="descclassname">nibabel.analyze.</code><code class="descname">AnalyzeImage</code><span class="sig-paren">(</span><em>dataobj</em>, <em>affine</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.spatialimages.html#nibabel.spatialimages.SpatialImage" title="nibabel.spatialimages.SpatialImage"><code class="xref py py-class docutils literal"><span class="pre">nibabel.spatialimages.SpatialImage</span></code></a></p>
<p>Class for basic Analyze format image</p>
<p>Initialize image</p>
<p>The image is a combination of (array, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataobj</strong> : object</p>
<blockquote>
<div><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal"><span class="pre">shape</span></code> attribute
or property</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) array-like</p>
<blockquote>
<div><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</div></blockquote>
<p><strong>header</strong> : None or mapping or header instance, optional</p>
<blockquote>
<div><p>metadata for this image format</p>
</div></blockquote>
<p><strong>extra</strong> : None or mapping, optional</p>
<blockquote>
<div><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</div></blockquote>
<p><strong>file_map</strong> : mapping, optional</p>
<blockquote class="last">
<div><p>mapping giving file information for this image format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.analyze.AnalyzeImage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dataobj</em>, <em>affine</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize image</p>
<p>The image is a combination of (array, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataobj</strong> : object</p>
<blockquote>
<div><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal"><span class="pre">shape</span></code> attribute
or property</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) array-like</p>
<blockquote>
<div><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</div></blockquote>
<p><strong>header</strong> : None or mapping or header instance, optional</p>
<blockquote>
<div><p>metadata for this image format</p>
</div></blockquote>
<p><strong>extra</strong> : None or mapping, optional</p>
<blockquote>
<div><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</div></blockquote>
<p><strong>file_map</strong> : mapping, optional</p>
<blockquote class="last">
<div><p>mapping giving file information for this image format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeImage.ImageArrayProxy">
<code class="descname">ImageArrayProxy</code><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.ImageArrayProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">ArrayProxy</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeImage.files_types">
<code class="descname">files_types</code><em class="property"> = (('image', '.img'), ('header', '.hdr'))</em><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.files_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeImage.from_file_map">
<em class="property">classmethod </em><code class="descname">from_file_map</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.from_file_map" title="Permalink to this definition">¶</a></dt>
<dd><p>class method to create image from mapping in <cite>file_map `</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_map</strong> : dict</p>
<blockquote>
<div><p>Mapping with (kay, value) pairs of (<code class="docutils literal"><span class="pre">file_type</span></code>, FileHolder
instance giving file-likes for each file needed for this image
type.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>img</strong> : AnalyzeImage instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeImage.from_filename">
<em class="property">classmethod </em><code class="descname">from_filename</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.from_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>class method to create image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of image to load</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>img</strong> : Analyze Image instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeImage.get_data_dtype">
<code class="descname">get_data_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.get_data_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeImage.header_class">
<code class="descname">header_class</code><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.header_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.analyze.AnalyzeHeader" title="nibabel.analyze.AnalyzeHeader"><code class="xref py py-class docutils literal"><span class="pre">AnalyzeHeader</span></code></a></p>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.analyze.AnalyzeImage.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.load" title="Permalink to this definition">¶</a></dt>
<dd><p>class method to create image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of image to load</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>img</strong> : Analyze Image instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeImage.makeable">
<code class="descname">makeable</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.makeable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeImage.rw">
<code class="descname">rw</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.rw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeImage.set_data_dtype">
<code class="descname">set_data_dtype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.set_data_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.analyze.AnalyzeImage.to_file_map">
<code class="descname">to_file_map</code><span class="sig-paren">(</span><em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.to_file_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Write image to <cite>file_map</cite> or contained <code class="docutils literal"><span class="pre">self.file_map</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_map</strong> : None or mapping, optional</p>
<blockquote class="last">
<div><p>files mapping.  If None (default) use object&#8217;s <code class="docutils literal"><span class="pre">file_map</span></code>
attribute instead</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.analyze.AnalyzeImage.valid_exts">
<code class="descname">valid_exts</code><em class="property"> = ('.img', '.hdr')</em><a class="headerlink" href="#nibabel.analyze.AnalyzeImage.valid_exts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="load">
<h2>load<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.analyze.load">
<code class="descclassname">nibabel.analyze.</code><code class="descname">load</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.analyze.load" title="Permalink to this definition">¶</a></dt>
<dd><p>class method to create image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of image to load</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>img</strong> : Analyze Image instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2016, Matthew Brett, Michael Hanke, Eric Larson, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>