<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &#8212; NiBabel 2.1.1dev documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.1.1dev documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="streamlines" href="nibabel.streamlines.html" />
    <link rel="prev" title="ecat" href="nibabel.ecat.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.streamlines.html" title="streamlines"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.ecat.html" title="ecat"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">parrec</span></code></a><ul>
<li><a class="reference internal" href="#par-file-format">PAR file format</a><ul>
<li><a class="reference internal" href="#general-information">General information</a></li>
<li><a class="reference internal" href="#image-information">Image information</a></li>
<li><a class="reference internal" href="#orientation">Orientation</a></li>
<li><a class="reference internal" href="#data-type">Data type</a></li>
<li><a class="reference internal" href="#data-sorting">Data Sorting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parrecarrayproxy"><code class="docutils literal"><span class="pre">PARRECArrayProxy</span></code></a></li>
<li><a class="reference internal" href="#parrecerror"><code class="docutils literal"><span class="pre">PARRECError</span></code></a></li>
<li><a class="reference internal" href="#parrecheader"><code class="docutils literal"><span class="pre">PARRECHeader</span></code></a></li>
<li><a class="reference internal" href="#parrecimage"><code class="docutils literal"><span class="pre">PARRECImage</span></code></a></li>
<li><a class="reference internal" href="#exts2pars">exts2pars</a></li>
<li><a class="reference internal" href="#load">load</a></li>
<li><a class="reference internal" href="#one-line">one_line</a></li>
<li><a class="reference internal" href="#parse-par-header">parse_PAR_header</a></li>
<li><a class="reference internal" href="#vol-is-full">vol_is_full</a></li>
<li><a class="reference internal" href="#vol-numbers">vol_numbers</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.ecat.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">ecat</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.streamlines.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">streamlines</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.parrec.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.parrec">
<span id="parrec"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">parrec</span></code><a class="headerlink" href="#module-nibabel.parrec" title="Permalink to this headline">¶</a></h1>
<p>Read images in PAR/REC format.</p>
<p>This is yet another MRI image format generated by Philips scanners. It is an
ASCII header (PAR) plus a binary blob (REC).</p>
<p>This implementation aims to read version 4.0 through 4.2 of this format. Other
versions could probably be supported, but we need example images to test
against.  If you want us to support another version, and have an image we can
add to the test suite, let us know.  You would make us very happy by submitting
a pull request.</p>
<div class="section" id="par-file-format">
<h2>PAR file format<a class="headerlink" href="#par-file-format" title="Permalink to this headline">¶</a></h2>
<p>The PAR format appears to have two sections:</p>
<div class="section" id="general-information">
<h3>General information<a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h3>
<p>This is a set of lines each giving one key : value pair, examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>.    EPI factor        &lt;0,1=no EPI&gt;     :   39
.    Dynamic scan      &lt;0=no 1=yes&gt; ?   :   1
.    Diffusion         &lt;0=no 1=yes&gt; ?   :   0
</pre></div>
</div>
<p>(from <code class="docutils literal"><span class="pre">nibabel/tests/data/phantom_EPI_asc_CLEAR_2_1.PAR</span></code>)</p>
</div>
<div class="section" id="image-information">
<h3>Image information<a class="headerlink" href="#image-information" title="Permalink to this headline">¶</a></h3>
<p>There is a <code class="docutils literal"><span class="pre">#</span></code> prefixed list of fields under the heading &#8220;IMAGE INFORMATION
DEFINITION&#8221;.  From the same file, here is the start of this list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># === IMAGE INFORMATION DEFINITION =============================================</span>
<span class="c1">#  The rest of this file contains ONE line per image, this line contains the following information:</span>
<span class="c1">#</span>
<span class="c1">#  slice number                             (integer)</span>
<span class="c1">#  echo number                              (integer)</span>
<span class="c1">#  dynamic scan number                      (integer)</span>
</pre></div>
</div>
<p>There follows a space separated table with values for these fields, each row
containing all the named values. Here are the first few lines from the example
file above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># === IMAGE INFORMATION ==========================================================</span>
<span class="c1">#  sl ec  dyn ph ty    idx pix scan% rec size                (re)scale              window        angulation              offcentre        thick   gap   info      spacing     echo     dtime   ttime    diff  avg  flip    freq   RR-int  turbo delay b grad cont anis         diffusion       L.ty</span>

<span class="mi">1</span>   <span class="mi">1</span>    <span class="mi">1</span>  <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span>     <span class="mi">0</span>  <span class="mi">16</span>    <span class="mi">62</span>   <span class="mi">64</span>   <span class="mi">64</span>     <span class="mf">0.00000</span>   <span class="mf">1.29035</span> <span class="mf">4.28404e-003</span>  <span class="mi">1070</span>  <span class="mi">1860</span> <span class="o">-</span><span class="mf">13.26</span>  <span class="o">-</span><span class="mf">0.00</span>  <span class="o">-</span><span class="mf">0.00</span>    <span class="mf">2.51</span>   <span class="o">-</span><span class="mf">0.81</span>   <span class="o">-</span><span class="mf">8.69</span>  <span class="mf">6.000</span>  <span class="mf">2.000</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span>  <span class="mf">3.750</span>  <span class="mf">3.750</span>  <span class="mf">30.00</span>    <span class="mf">0.00</span>     <span class="mf">0.00</span>    <span class="mf">0.00</span>   <span class="mi">0</span>   <span class="mf">90.00</span>     <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">39</span>   <span class="mf">0.0</span>  <span class="mi">1</span>   <span class="mi">1</span>    <span class="mi">8</span>    <span class="mi">0</span>   <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>  <span class="mi">1</span>
<span class="mi">2</span>   <span class="mi">1</span>    <span class="mi">1</span>  <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span>     <span class="mi">1</span>  <span class="mi">16</span>    <span class="mi">62</span>   <span class="mi">64</span>   <span class="mi">64</span>     <span class="mf">0.00000</span>   <span class="mf">1.29035</span> <span class="mf">4.28404e-003</span>  <span class="mi">1122</span>  <span class="mi">1951</span> <span class="o">-</span><span class="mf">13.26</span>  <span class="o">-</span><span class="mf">0.00</span>  <span class="o">-</span><span class="mf">0.00</span>    <span class="mf">2.51</span>    <span class="mf">6.98</span>  <span class="o">-</span><span class="mf">10.53</span>  <span class="mf">6.000</span>  <span class="mf">2.000</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span>  <span class="mf">3.750</span>  <span class="mf">3.750</span>  <span class="mf">30.00</span>    <span class="mf">0.00</span>     <span class="mf">0.00</span>    <span class="mf">0.00</span>   <span class="mi">0</span>   <span class="mf">90.00</span>     <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">39</span>   <span class="mf">0.0</span>  <span class="mi">1</span>   <span class="mi">1</span>    <span class="mi">8</span>    <span class="mi">0</span>   <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>  <span class="mi">1</span>
<span class="mi">3</span>   <span class="mi">1</span>    <span class="mi">1</span>  <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span>     <span class="mi">2</span>  <span class="mi">16</span>    <span class="mi">62</span>   <span class="mi">64</span>   <span class="mi">64</span>     <span class="mf">0.00000</span>   <span class="mf">1.29035</span> <span class="mf">4.28404e-003</span>  <span class="mi">1137</span>  <span class="mi">1977</span> <span class="o">-</span><span class="mf">13.26</span>  <span class="o">-</span><span class="mf">0.00</span>  <span class="o">-</span><span class="mf">0.00</span>    <span class="mf">2.51</span>   <span class="mf">14.77</span>  <span class="o">-</span><span class="mf">12.36</span>  <span class="mf">6.000</span>  <span class="mf">2.000</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span>  <span class="mf">3.750</span>  <span class="mf">3.750</span>  <span class="mf">30.00</span>    <span class="mf">0.00</span>     <span class="mf">0.00</span>    <span class="mf">0.00</span>   <span class="mi">0</span>   <span class="mf">90.00</span>     <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">39</span>   <span class="mf">0.0</span>  <span class="mi">1</span>   <span class="mi">1</span>    <span class="mi">8</span>    <span class="mi">0</span>   <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>  <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="orientation">
<h3>Orientation<a class="headerlink" href="#orientation" title="Permalink to this headline">¶</a></h3>
<p>PAR files refer to orientations &#8220;ap&#8221;, &#8220;fh&#8221; and &#8220;rl&#8221;.</p>
<p>Nibabel&#8217;s required affine output axes are RAS (left to Right, posterior to
Anterior, inferior to Superior). The correspondence of the PAR file&#8217;s axes to
RAS axes is:</p>
<ul class="simple">
<li>ap = anterior -&gt; posterior = negative A in RAS = P</li>
<li>fh = foot -&gt; head = S in RAS = S</li>
<li>rl = right -&gt; left = negative R in RAS = L</li>
</ul>
<p>We therefore call the PAR file&#8217;s axis system &#8220;PSL&#8221; (Posterior, Superior, Left).</p>
<p>The orientation of the PAR file axes corresponds to DICOM&#8217;s LPS coordinate
system (right to Left, anterior to Posterior, inferior to Superior), but in a
different order.</p>
</div>
<div class="section" id="data-type">
<h3>Data type<a class="headerlink" href="#data-type" title="Permalink to this headline">¶</a></h3>
<p>It seems that everyone agrees that Philips stores REC data in little-endian
format - see <a class="reference external" href="https://github.com/nipy/nibabel/issues/274">https://github.com/nipy/nibabel/issues/274</a></p>
<p>Philips XML header files, and some previous experience, suggest that the REC
data is always stored as 8 or 16 bit unsigned integers - see
<a class="reference external" href="https://github.com/nipy/nibabel/issues/275">https://github.com/nipy/nibabel/issues/275</a></p>
</div>
<div class="section" id="data-sorting">
<h3>Data Sorting<a class="headerlink" href="#data-sorting" title="Permalink to this headline">¶</a></h3>
<p>PAR/REC files have a large number of potential image dimensions.  To handle
sorting of volumes in PAR/REC files based on these fields and not the order
slices first appear in the PAR file, the <code class="docutils literal"><span class="pre">strict_sort</span></code> flag of
<code class="docutils literal"><span class="pre">nibabel.load</span></code> (or <code class="docutils literal"><span class="pre">parrec.load</span></code>) should be set to <code class="docutils literal"><span class="pre">True</span></code>.  The fields
that are taken into account during sorting are:</p>
<blockquote>
<div><ul class="simple">
<li>slice number</li>
<li>echo number</li>
<li>cardiac phase number</li>
<li>gradient orientation number</li>
<li>diffusion b value number</li>
<li>label type  (ASL tag vs. control)</li>
<li>dynamic scan number</li>
<li>image_type_mr  (Re, Im, Mag, Phase)</li>
</ul>
</div></blockquote>
<p>Slices are sorted into the third dimension and the
order of preference for sorting along the 4th dimension corresponds to the
order in the list above.  If the image data has more than 4 dimensions these
will all be concatenated along the 4th dimension.  For example, for a scan with
two echos and two dynamics, the 4th dimension will have both echos of dynamic 1
prior to the two echos for dynamic 2.</p>
<p>The``get_volume_labels`` method of the header returns a dictionary containing
the PAR field labels for this 4th dimension.</p>
<p>The volume sorting described above can be enabled in the parrec2nii command
utility via the option &#8220;&#8211;strict-sort&#8221;.  The dimension info can be exported
to a CSV file by adding the option &#8220;&#8211;volume-info&#8221;.</p>
</div>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.PARRECArrayProxy" title="nibabel.parrec.PARRECArrayProxy"><code class="xref py py-obj docutils literal"><span class="pre">PARRECArrayProxy</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Initialize PARREC array proxy</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.PARRECError" title="nibabel.parrec.PARRECError"><code class="xref py py-obj docutils literal"><span class="pre">PARRECError</span></code></a></td>
<td>Exception for PAR/REC format related problems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.PARRECHeader" title="nibabel.parrec.PARRECHeader"><code class="xref py py-obj docutils literal"><span class="pre">PARRECHeader</span></code></a>(info,&nbsp;image_defs[,&nbsp;...])</td>
<td>PAR/REC header</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.PARRECImage" title="nibabel.parrec.PARRECImage"><code class="xref py py-obj docutils literal"><span class="pre">PARRECImage</span></code></a>(dataobj,&nbsp;affine[,&nbsp;header,&nbsp;...])</td>
<td>PAR/REC image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.exts2pars" title="nibabel.parrec.exts2pars"><code class="xref py py-obj docutils literal"><span class="pre">exts2pars</span></code></a>(exts_source)</td>
<td>Parse, return any PAR headers from NIfTI extensions in <cite>exts_source</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.load" title="nibabel.parrec.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a></td>
<td>Create PARREC image from filename <cite>filename</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.one_line" title="nibabel.parrec.one_line"><code class="xref py py-obj docutils literal"><span class="pre">one_line</span></code></a>(long_str)</td>
<td>Make maybe mutli-line <cite>long_str</cite> into one long line</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.parse_PAR_header" title="nibabel.parrec.parse_PAR_header"><code class="xref py py-obj docutils literal"><span class="pre">parse_PAR_header</span></code></a>(fobj)</td>
<td>Parse a PAR header and aggregate all information into useful containers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.vol_is_full" title="nibabel.parrec.vol_is_full"><code class="xref py py-obj docutils literal"><span class="pre">vol_is_full</span></code></a>(slice_nos,&nbsp;slice_max[,&nbsp;slice_min])</td>
<td>Vector with True for slices in complete volume, False otherwise</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.vol_numbers" title="nibabel.parrec.vol_numbers"><code class="xref py py-obj docutils literal"><span class="pre">vol_numbers</span></code></a>(slice_nos)</td>
<td>Calculate volume numbers inferred from slice numbers <cite>slice_nos</cite></td>
</tr>
</tbody>
</table>
<div class="section" id="parrecarrayproxy">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECArrayProxy" title="nibabel.parrec.PARRECArrayProxy"><code class="xref py py-class docutils literal"><span class="pre">PARRECArrayProxy</span></code></a><a class="headerlink" href="#parrecarrayproxy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECArrayProxy">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECArrayProxy</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize PARREC array proxy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_like</strong> : file-like object</p>
<blockquote>
<div><p>Filename or object implementing <code class="docutils literal"><span class="pre">read,</span> <span class="pre">seek,</span> <span class="pre">tell</span></code></p>
</div></blockquote>
<p><strong>header</strong> : PARRECHeader instance</p>
<blockquote>
<div><p>Implementing <code class="docutils literal"><span class="pre">get_data_shape,</span> <span class="pre">get_data_dtype</span></code>,
<code class="docutils literal"><span class="pre">get_sorted_slice_indices</span></code>, <code class="docutils literal"><span class="pre">get_data_scaling</span></code>,
<code class="docutils literal"><span class="pre">get_rec_shape</span></code>.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading data.
If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.  If one of
{&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite> value of
True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If <cite>file_like</cite>
cannot be memory-mapped, ignore <cite>mmap</cite> value and read array from
file.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;fp&#8217;, &#8216;dv&#8217;}, optional, keyword only</p>
<blockquote class="last">
<div><p>Type of scaling to use - see header <code class="docutils literal"><span class="pre">get_data_scaling</span></code> method.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.parrec.PARRECArrayProxy.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize PARREC array proxy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_like</strong> : file-like object</p>
<blockquote>
<div><p>Filename or object implementing <code class="docutils literal"><span class="pre">read,</span> <span class="pre">seek,</span> <span class="pre">tell</span></code></p>
</div></blockquote>
<p><strong>header</strong> : PARRECHeader instance</p>
<blockquote>
<div><p>Implementing <code class="docutils literal"><span class="pre">get_data_shape,</span> <span class="pre">get_data_dtype</span></code>,
<code class="docutils literal"><span class="pre">get_sorted_slice_indices</span></code>, <code class="docutils literal"><span class="pre">get_data_scaling</span></code>,
<code class="docutils literal"><span class="pre">get_rec_shape</span></code>.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading data.
If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.  If one of
{&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite> value of
True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If <cite>file_like</cite>
cannot be memory-mapped, ignore <cite>mmap</cite> value and read array from
file.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;fp&#8217;, &#8216;dv&#8217;}, optional, keyword only</p>
<blockquote class="last">
<div><p>Type of scaling to use - see header <code class="docutils literal"><span class="pre">get_data_scaling</span></code> method.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECArrayProxy.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECArrayProxy.get_unscaled">
<code class="descname">get_unscaled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.get_unscaled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECArrayProxy.is_proxy">
<code class="descname">is_proxy</code><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.is_proxy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECArrayProxy.shape">
<code class="descname">shape</code><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="parrecerror">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECError" title="nibabel.parrec.PARRECError"><code class="xref py py-class docutils literal"><span class="pre">PARRECError</span></code></a><a class="headerlink" href="#parrecerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECError">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECError</code><a class="headerlink" href="#nibabel.parrec.PARRECError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Exception for PAR/REC format related problems.</p>
<p>To be raised whenever PAR/REC is not happy, or we are not happy with
PAR/REC.</p>
<dl class="method">
<dt id="nibabel.parrec.PARRECError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="parrecheader">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECHeader" title="nibabel.parrec.PARRECHeader"><code class="xref py py-class docutils literal"><span class="pre">PARRECHeader</span></code></a><a class="headerlink" href="#parrecheader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECHeader">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECHeader</code><span class="sig-paren">(</span><em>info</em>, <em>image_defs</em>, <em>permit_truncated=False</em>, <em>strict_sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.spatialimages.html#nibabel.spatialimages.SpatialHeader" title="nibabel.spatialimages.SpatialHeader"><code class="xref py py-class docutils literal"><span class="pre">nibabel.spatialimages.SpatialHeader</span></code></a></p>
<p>PAR/REC header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : dict</p>
<blockquote>
<div><p>&#8220;General information&#8221; from the PAR file (as returned by
<cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>image_defs</strong> : array</p>
<blockquote>
<div><p>Structured array with image definitions from the PAR file (as
returned by <cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : bool, optional</p>
<blockquote>
<div><p>If True, a warning is emitted instead of an error when a truncated
recording is detected.</p>
</div></blockquote>
<p><strong>strict_sort</strong> : bool, optional, keyword-only</p>
<blockquote class="last">
<div><p>If True, a larger number of header fields are used while sorting
the REC data array.  This may produce a different sort order than
<cite>strict_sort=False</cite>, where volumes are sorted by the order in which
the slices appear in the .PAR file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>info</em>, <em>image_defs</em>, <em>permit_truncated=False</em>, <em>strict_sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : dict</p>
<blockquote>
<div><p>&#8220;General information&#8221; from the PAR file (as returned by
<cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>image_defs</strong> : array</p>
<blockquote>
<div><p>Structured array with image definitions from the PAR file (as
returned by <cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : bool, optional</p>
<blockquote>
<div><p>If True, a warning is emitted instead of an error when a truncated
recording is detected.</p>
</div></blockquote>
<p><strong>strict_sort</strong> : bool, optional, keyword-only</p>
<blockquote class="last">
<div><p>If True, a larger number of header fields are used while sorting
the REC data array.  This may produce a different sort order than
<cite>strict_sort=False</cite>, where volumes are sorted by the order in which
the slices appear in the .PAR file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.as_analyze_map">
<code class="descname">as_analyze_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.as_analyze_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert PAR parameters to NIFTI1 format</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECHeader.from_fileobj">
<em class="property">classmethod </em><code class="descname">from_fileobj</code><span class="sig-paren">(</span><em>klass</em>, <em>fileobj</em>, <em>permit_truncated=False</em>, <em>strict_sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.from_fileobj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECHeader.from_header">
<em class="property">classmethod </em><code class="descname">from_header</code><span class="sig-paren">(</span><em>klass</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.from_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><em>origin='scanner'</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute affine transformation into scanner space.</p>
<p>The method only considers global rotation and offset settings in the
header and ignores potentially deviating information in the image
definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>origin</strong> : {&#8216;scanner&#8217;, &#8216;fov&#8217;}</p>
<blockquote>
<div><p>Transformation origin. By default the transformation is computed
relative to the scanner&#8217;s iso center. If &#8216;fov&#8217; is requested the
transformation origin will be the center of the field of view
instead.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aff</strong> : (4, 4) array</p>
<blockquote class="last">
<div><p>4x4 array, with output axis order corresponding to RAS or (x,y,z)
or (lr, pa, fh).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Transformations appear to be specified in (ap, fh, rl) axes.  The
orientation of data is recorded in the &#8220;slice orientation&#8221; field of the
PAR header &#8220;General Information&#8221;.</p>
<p>We need to:</p>
<ul class="simple">
<li>translate to coordinates in terms of the center of the FOV</li>
<li>apply voxel size scaling</li>
<li>reorder / flip the data to Philips&#8217; PSL axes</li>
<li>apply the rotations</li>
<li>apply any isocenter scaling offset if <cite>origin</cite> == &#8220;scanner&#8221;</li>
<li>reorder and flip to RAS axes</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_bvals_bvecs">
<code class="descname">get_bvals_bvecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_bvals_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get bvals and bvecs from data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b_vals</strong> : None or array</p>
<blockquote>
<div><p>Array of b values, shape (n_directions,), or None if not a
diffusion acquisition.</p>
</div></blockquote>
<p><strong>b_vectors</strong> : None or array</p>
<blockquote class="last">
<div><p>Array of b vectors, shape (n_directions, 3), or None if not a
diffusion acquisition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_data_offset">
<code class="descname">get_data_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_data_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>PAR header always has 0 data offset (into REC file)</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_data_scaling">
<code class="descname">get_data_scaling</code><span class="sig-paren">(</span><em>method='dv'</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns scaling slope and intercept.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : {&#8216;fp&#8217;, &#8216;dv&#8217;}</p>
<blockquote>
<div><p>Scaling settings to be reported &#8211; see notes below.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>slope</strong> : array</p>
<blockquote>
<div><p>scaling slope</p>
</div></blockquote>
<p><strong>intercept</strong> : array</p>
<blockquote class="last">
<div><p>scaling intercept</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The PAR header contains two different scaling settings: &#8216;dv&#8217; (value on
console) and &#8216;fp&#8217; (floating point value). Here is how they are defined:</p>
<p>DV = PV * RS + RI
FP = DV / (RS * SS)</p>
<p>where:</p>
<p>PV: value in REC
RS: rescale slope
RI: rescale intercept
SS: scale slope</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_def">
<code class="descname">get_def</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single image definition field (or None if missing)</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_echo_train_length">
<code class="descname">get_echo_train_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_echo_train_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Echo train length of the recording</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_q_vectors">
<code class="descname">get_q_vectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_q_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Q vectors from the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>q_vectors</strong> : None or array</p>
<blockquote class="last">
<div><p>Array of q vectors (bvals * bvecs), or None if not a diffusion
acquisition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_rec_shape">
<code class="descname">get_rec_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_rec_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_slice_orientation">
<code class="descname">get_slice_orientation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_slice_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slice orientation label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>orientation</strong> : {&#8216;transverse&#8217;, &#8216;sagittal&#8217;, &#8216;coronal&#8217;}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_sorted_slice_indices">
<code class="descname">get_sorted_slice_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_sorted_slice_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices to sort (and maybe discard) slices in REC file.</p>
<p>If the recording is truncated, the returned indices take care of
discarding any slice indices from incomplete volumes.</p>
<p>If <cite>self.strict_sort</cite> is True, a more complicated sorting based on
multiple fields from the .PAR file is used.  This may produce a
different sort order than <cite>strict_sort=False</cite>, where volumes are sorted
by the order in which the slices appear in the .PAR file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>slice_indices</strong> : list</p>
<blockquote class="last">
<div><p>List for indexing into the last (third) dimension of the REC data
array, and (equivalently) the only dimension of
<code class="docutils literal"><span class="pre">self.image_defs</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_volume_labels">
<code class="descname">get_volume_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_volume_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic labels corresponding to the final data dimension(s).</p>
<p>This is useful for custom data sorting.  A subset of the info in
<code class="docutils literal"><span class="pre">self.image_defs</span></code> is returned in an order that matches the final
data dimension(s).  Only labels that have more than one unique value
across the dataset will be returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sort_info</strong> : dict</p>
<blockquote class="last">
<div><p>Each key corresponds to volume labels for a dynamically varying
sequence dimension.  The ordering of the labels matches the volume
ordering determined via <code class="docutils literal"><span class="pre">self.get_sorted_slice_indices</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_voxel_size">
<code class="descname">get_voxel_size</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_voxel_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the spatial extent of a voxel.</p>
<p>get_voxel_size deprecated. Please use &#8220;get_zooms&#8221; instead.</p>
<ul class="simple">
<li>deprecated from version: 2.0</li>
<li>Will raise &lt;class &#8216;nibabel.deprecator.ExpiredDeprecationError&#8217;&gt; as of version: 4.0</li>
</ul>
<p>Does not include the slice gap in the slice extent.</p>
<p>If you need the slice thickness not including the slice gap, use
<code class="docutils literal"><span class="pre">self.image_defs['slice</span> <span class="pre">thickness']</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">vox_size: shape (3,) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_water_fat_shift">
<code class="descname">get_water_fat_shift</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_water_fat_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Water fat shift, in pixels</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.set_data_offset">
<code class="descname">set_data_offset</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.set_data_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>PAR header always has 0 data offset (into REC file)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="parrecimage">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECImage" title="nibabel.parrec.PARRECImage"><code class="xref py py-class docutils literal"><span class="pre">PARRECImage</span></code></a><a class="headerlink" href="#parrecimage" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECImage">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECImage</code><span class="sig-paren">(</span><em>dataobj</em>, <em>affine</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.spatialimages.html#nibabel.spatialimages.SpatialImage" title="nibabel.spatialimages.SpatialImage"><code class="xref py py-class docutils literal"><span class="pre">nibabel.spatialimages.SpatialImage</span></code></a></p>
<p>PAR/REC image</p>
<p>Initialize image</p>
<p>The image is a combination of (array, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataobj</strong> : object</p>
<blockquote>
<div><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal"><span class="pre">shape</span></code> attribute
or property</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) array-like</p>
<blockquote>
<div><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</div></blockquote>
<p><strong>header</strong> : None or mapping or header instance, optional</p>
<blockquote>
<div><p>metadata for this image format</p>
</div></blockquote>
<p><strong>extra</strong> : None or mapping, optional</p>
<blockquote>
<div><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</div></blockquote>
<p><strong>file_map</strong> : mapping, optional</p>
<blockquote class="last">
<div><p>mapping giving file information for this image format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.parrec.PARRECImage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dataobj</em>, <em>affine</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize image</p>
<p>The image is a combination of (array, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataobj</strong> : object</p>
<blockquote>
<div><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal"><span class="pre">shape</span></code> attribute
or property</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) array-like</p>
<blockquote>
<div><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</div></blockquote>
<p><strong>header</strong> : None or mapping or header instance, optional</p>
<blockquote>
<div><p>metadata for this image format</p>
</div></blockquote>
<p><strong>extra</strong> : None or mapping, optional</p>
<blockquote>
<div><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</div></blockquote>
<p><strong>file_map</strong> : mapping, optional</p>
<blockquote class="last">
<div><p>mapping giving file information for this image format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.ImageArrayProxy">
<code class="descname">ImageArrayProxy</code><a class="headerlink" href="#nibabel.parrec.PARRECImage.ImageArrayProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.parrec.PARRECArrayProxy" title="nibabel.parrec.PARRECArrayProxy"><code class="xref py py-class docutils literal"><span class="pre">PARRECArrayProxy</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.files_types">
<code class="descname">files_types</code><em class="property"> = (('image', '.rec'), ('header', '.par'))</em><a class="headerlink" href="#nibabel.parrec.PARRECImage.files_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECImage.from_file_map">
<em class="property">classmethod </em><code class="descname">from_file_map</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.from_file_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from file map <cite>file_map</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_map</strong> : dict</p>
<blockquote>
<div><p>dict with keys <code class="docutils literal"><span class="pre">image,</span> <span class="pre">header</span></code> and values being fileholder
objects for the respective REC and PAR files.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote>
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
<p><strong>strict_sort</strong> : bool, optional, keyword-only</p>
<blockquote class="last">
<div><p>If True, a larger number of header fields are used while sorting
the REC data array.  This may produce a different sort order than
<cite>strict_sort=False</cite>, where volumes are sorted by the order in which
the slices appear in the .PAR file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECImage.from_filename">
<em class="property">classmethod </em><code class="descname">from_filename</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.from_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of &#8220;PAR&#8221; or &#8220;REC&#8221; file</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote>
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
<p><strong>strict_sort</strong> : bool, optional, keyword-only</p>
<blockquote class="last">
<div><p>If True, a larger number of header fields are used while sorting
the REC data array.  This may produce a different sort order than
<cite>strict_sort=False</cite>, where volumes are sorted by the order in which
the slices appear in the .PAR file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.header_class">
<code class="descname">header_class</code><a class="headerlink" href="#nibabel.parrec.PARRECImage.header_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.parrec.PARRECHeader" title="nibabel.parrec.PARRECHeader"><code class="xref py py-class docutils literal"><span class="pre">PARRECHeader</span></code></a></p>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECImage.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of &#8220;PAR&#8221; or &#8220;REC&#8221; file</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote>
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
<p><strong>strict_sort</strong> : bool, optional, keyword-only</p>
<blockquote class="last">
<div><p>If True, a larger number of header fields are used while sorting
the REC data array.  This may produce a different sort order than
<cite>strict_sort=False</cite>, where volumes are sorted by the order in which
the slices appear in the .PAR file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.makeable">
<code class="descname">makeable</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.parrec.PARRECImage.makeable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.rw">
<code class="descname">rw</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.parrec.PARRECImage.rw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.valid_exts">
<code class="descname">valid_exts</code><em class="property"> = ('.rec', '.par')</em><a class="headerlink" href="#nibabel.parrec.PARRECImage.valid_exts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="exts2pars">
<h2>exts2pars<a class="headerlink" href="#exts2pars" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.exts2pars">
<code class="descclassname">nibabel.parrec.</code><code class="descname">exts2pars</code><span class="sig-paren">(</span><em>exts_source</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.exts2pars" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse, return any PAR headers from NIfTI extensions in <cite>exts_source</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>exts_source</strong> : sequence or <cite>Nifti1Image</cite>, <cite>Nifti1Header</cite> instance</p>
<blockquote>
<div><p>A sequence of extensions, or header containing NIfTI extensions, or an
image containing a header with NIfTI extensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>par_headers</strong> : list</p>
<blockquote class="last">
<div><p>A list of PARRECHeader objects, usually empty or with one element, each
element contains a PARRECHeader read from the contained extensions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="load">
<h2>load<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.load">
<code class="descclassname">nibabel.parrec.</code><code class="descname">load</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of &#8220;PAR&#8221; or &#8220;REC&#8221; file</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote>
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
<p><strong>strict_sort</strong> : bool, optional, keyword-only</p>
<blockquote class="last">
<div><p>If True, a larger number of header fields are used while sorting
the REC data array.  This may produce a different sort order than
<cite>strict_sort=False</cite>, where volumes are sorted by the order in which
the slices appear in the .PAR file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="one-line">
<h2>one_line<a class="headerlink" href="#one-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.one_line">
<code class="descclassname">nibabel.parrec.</code><code class="descname">one_line</code><span class="sig-paren">(</span><em>long_str</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.one_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Make maybe mutli-line <cite>long_str</cite> into one long line</p>
</dd></dl>

</div>
<div class="section" id="parse-par-header">
<h2>parse_PAR_header<a class="headerlink" href="#parse-par-header" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.parse_PAR_header">
<code class="descclassname">nibabel.parrec.</code><code class="descname">parse_PAR_header</code><span class="sig-paren">(</span><em>fobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.parse_PAR_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a PAR header and aggregate all information into useful containers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fobj</strong> : file-object</p>
<blockquote>
<div><p>The PAR header file object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>general_info</strong> : dict</p>
<blockquote>
<div><p>Contains all &#8220;General Information&#8221; from the header file</p>
</div></blockquote>
<p><strong>image_info</strong> : ndarray</p>
<blockquote class="last">
<div><p>Structured array with fields giving all &#8220;Image information&#8221; in the
header</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="vol-is-full">
<h2>vol_is_full<a class="headerlink" href="#vol-is-full" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.vol_is_full">
<code class="descclassname">nibabel.parrec.</code><code class="descname">vol_is_full</code><span class="sig-paren">(</span><em>slice_nos</em>, <em>slice_max</em>, <em>slice_min=1</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.vol_is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector with True for slices in complete volume, False otherwise</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>slice_nos</strong> : sequence</p>
<blockquote>
<div><p>Sequence of slice numbers, e.g. <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>.</p>
</div></blockquote>
<p><strong>slice_max</strong> : int</p>
<blockquote>
<div><p>Highest slice number for a full slice set.  Slice set will be
<code class="docutils literal"><span class="pre">range(slice_min,</span> <span class="pre">slice_max+1)</span></code>.</p>
</div></blockquote>
<p><strong>slice_min</strong> : int, optional</p>
<blockquote>
<div><p>Lowest slice number for full slice set.  Default is 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_full</strong> : array</p>
<blockquote>
<div><p>Bool vector with True for slices in full volumes, False for slices in
partial volumes.  A full volume is a volume with all slices in the
<code class="docutils literal"><span class="pre">slice</span> <span class="pre">set</span></code> as defined above.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>if any value in <cite>slice_nos</cite> is outside slice set indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="vol-numbers">
<h2>vol_numbers<a class="headerlink" href="#vol-numbers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.vol_numbers">
<code class="descclassname">nibabel.parrec.</code><code class="descname">vol_numbers</code><span class="sig-paren">(</span><em>slice_nos</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.vol_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate volume numbers inferred from slice numbers <cite>slice_nos</cite></p>
<p>The volume number for each slice is the number of times this slice number
has occurred previously in the <cite>slice_nos</cite> sequence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>slice_nos</strong> : sequence</p>
<blockquote>
<div><p>Sequence of slice numbers, e.g. <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vol_nos</strong> : list</p>
<blockquote class="last">
<div><p>A list, the same length of <cite>slice_nos</cite> giving the volume number for
each corresponding slice number.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2016, Matthew Brett, Michael Hanke, Eric Larson, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>