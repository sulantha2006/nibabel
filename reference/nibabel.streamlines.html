<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &#8212; NiBabel 2.1.1dev documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.1.1dev documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="trackvis" href="nibabel.trackvis.html" />
    <link rel="prev" title="parrec" href="nibabel.parrec.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.trackvis.html" title="trackvis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.parrec.html" title="parrec"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">streamlines</span></code></a><ul>
<li><a class="reference internal" href="#module-nibabel.streamlines.array_sequence">Module: <code class="docutils literal"><span class="pre">streamlines.array_sequence</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.header">Module: <code class="docutils literal"><span class="pre">streamlines.header</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.tractogram">Module: <code class="docutils literal"><span class="pre">streamlines.tractogram</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.tractogram_file">Module: <code class="docutils literal"><span class="pre">streamlines.tractogram_file</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.trk">Module: <code class="docutils literal"><span class="pre">streamlines.trk</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.utils">Module: <code class="docutils literal"><span class="pre">streamlines.utils</span></code></a><ul>
<li><a class="reference internal" href="#detect-format">detect_format</a></li>
<li><a class="reference internal" href="#is-supported">is_supported</a></li>
<li><a class="reference internal" href="#load">load</a></li>
<li><a class="reference internal" href="#save">save</a></li>
<li><a class="reference internal" href="#arraysequence"><code class="docutils literal"><span class="pre">ArraySequence</span></code></a></li>
<li><a class="reference internal" href="#create-arraysequences-from-generator">create_arraysequences_from_generator</a></li>
<li><a class="reference internal" href="#is-array-sequence">is_array_sequence</a></li>
<li><a class="reference internal" href="#is-ndarray-of-int-or-bool">is_ndarray_of_int_or_bool</a></li>
<li><a class="reference internal" href="#field"><code class="docutils literal"><span class="pre">Field</span></code></a></li>
<li><a class="reference internal" href="#lazydict"><code class="docutils literal"><span class="pre">LazyDict</span></code></a></li>
<li><a class="reference internal" href="#lazytractogram"><code class="docutils literal"><span class="pre">LazyTractogram</span></code></a></li>
<li><a class="reference internal" href="#perarraydict"><code class="docutils literal"><span class="pre">PerArrayDict</span></code></a></li>
<li><a class="reference internal" href="#perarraysequencedict"><code class="docutils literal"><span class="pre">PerArraySequenceDict</span></code></a></li>
<li><a class="reference internal" href="#sliceabledatadict"><code class="docutils literal"><span class="pre">SliceableDataDict</span></code></a></li>
<li><a class="reference internal" href="#tractogram"><code class="docutils literal"><span class="pre">Tractogram</span></code></a></li>
<li><a class="reference internal" href="#tractogramitem"><code class="docutils literal"><span class="pre">TractogramItem</span></code></a></li>
<li><a class="reference internal" href="#is-data-dict">is_data_dict</a></li>
<li><a class="reference internal" href="#is-lazy-dict">is_lazy_dict</a></li>
<li><a class="reference internal" href="#dataerror"><code class="docutils literal"><span class="pre">DataError</span></code></a></li>
<li><a class="reference internal" href="#extensionwarning"><code class="docutils literal"><span class="pre">ExtensionWarning</span></code></a></li>
<li><a class="reference internal" href="#headererror"><code class="docutils literal"><span class="pre">HeaderError</span></code></a></li>
<li><a class="reference internal" href="#headerwarning"><code class="docutils literal"><span class="pre">HeaderWarning</span></code></a></li>
<li><a class="reference internal" href="#tractogramfile"><code class="docutils literal"><span class="pre">TractogramFile</span></code></a></li>
<li><a class="reference internal" href="#abstractclassmethod"><code class="docutils literal"><span class="pre">abstractclassmethod</span></code></a></li>
<li><a class="reference internal" href="#trkfile"><code class="docutils literal"><span class="pre">TrkFile</span></code></a></li>
<li><a class="reference internal" href="#create-empty-header">create_empty_header</a></li>
<li><a class="reference internal" href="#decode-value-from-name">decode_value_from_name</a></li>
<li><a class="reference internal" href="#encode-value-in-name">encode_value_in_name</a></li>
<li><a class="reference internal" href="#get-affine-rasmm-to-trackvis">get_affine_rasmm_to_trackvis</a></li>
<li><a class="reference internal" href="#get-affine-trackvis-to-rasmm">get_affine_trackvis_to_rasmm</a></li>
<li><a class="reference internal" href="#get-affine-from-reference">get_affine_from_reference</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.parrec.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">parrec</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.trackvis.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">trackvis</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.streamlines.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.streamlines">
<span id="streamlines"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">streamlines</span></code><a class="headerlink" href="#module-nibabel.streamlines" title="Permalink to this headline">¶</a></h1>
<p>Multiformat-capable streamline format read / write interface</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.detect_format" title="nibabel.streamlines.detect_format"><code class="xref py py-obj docutils literal"><span class="pre">detect_format</span></code></a>(fileobj)</td>
<td>Returns the StreamlinesFile object guessed from the file-like object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.is_supported" title="nibabel.streamlines.is_supported"><code class="xref py py-obj docutils literal"><span class="pre">is_supported</span></code></a>(fileobj)</td>
<td>Checks if the file-like object if supported by NiBabel.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.load" title="nibabel.streamlines.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a>(fileobj[,&nbsp;lazy_load])</td>
<td>Loads streamlines in <em>RAS+</em> and <em>mm</em> space from a file-like object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.save" title="nibabel.streamlines.save"><code class="xref py py-obj docutils literal"><span class="pre">save</span></code></a>(tractogram,&nbsp;filename,&nbsp;**kwargs)</td>
<td>Saves a tractogram to a file.</td>
</tr>
</tbody>
</table>
<div class="section" id="module-nibabel.streamlines.array_sequence">
<span id="module-streamlines-array-sequence"></span><h2>Module: <code class="xref py py-mod docutils literal"><span class="pre">streamlines.array_sequence</span></code><a class="headerlink" href="#module-nibabel.streamlines.array_sequence" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-obj docutils literal"><span class="pre">ArraySequence</span></code></a>([iterable,&nbsp;buffer_size])</td>
<td>Sequence of ndarrays having variable first dimension sizes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.array_sequence.create_arraysequences_from_generator" title="nibabel.streamlines.array_sequence.create_arraysequences_from_generator"><code class="xref py py-obj docutils literal"><span class="pre">create_arraysequences_from_generator</span></code></a>(gen,&nbsp;n)</td>
<td>Creates <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> objects from a generator yielding tuples</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.array_sequence.is_array_sequence" title="nibabel.streamlines.array_sequence.is_array_sequence"><code class="xref py py-obj docutils literal"><span class="pre">is_array_sequence</span></code></a>(obj)</td>
<td>Return True if <cite>obj</cite> is an array sequence.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool" title="nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool"><code class="xref py py-obj docutils literal"><span class="pre">is_ndarray_of_int_or_bool</span></code></a>(obj)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.header">
<span id="module-streamlines-header"></span><h2>Module: <code class="xref py py-mod docutils literal"><span class="pre">streamlines.header</span></code><a class="headerlink" href="#module-nibabel.streamlines.header" title="Permalink to this headline">¶</a></h2>
<p>Field class defining common header fields in tractogram files</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.header.Field" title="nibabel.streamlines.header.Field"><code class="xref py py-obj docutils literal"><span class="pre">Field</span></code></a></td>
<td>Header fields common to multiple streamline file formats.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.tractogram">
<span id="module-streamlines-tractogram"></span><h2>Module: <code class="xref py py-mod docutils literal"><span class="pre">streamlines.tractogram</span></code><a class="headerlink" href="#module-nibabel.streamlines.tractogram" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-obj docutils literal"><span class="pre">LazyDict</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Dictionary of generator functions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-obj docutils literal"><span class="pre">LazyTractogram</span></code></a>([streamlines,&nbsp;...])</td>
<td>Lazy container for streamlines and their data information.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-obj docutils literal"><span class="pre">PerArrayDict</span></code></a>([n_rows])</td>
<td>Dictionary for which key access can do slicing on the values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="nibabel.streamlines.tractogram.PerArraySequenceDict"><code class="xref py py-obj docutils literal"><span class="pre">PerArraySequenceDict</span></code></a>([n_rows])</td>
<td>Dictionary for which key access can do slicing on the values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="nibabel.streamlines.tractogram.SliceableDataDict"><code class="xref py py-obj docutils literal"><span class="pre">SliceableDataDict</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Dictionary for which key access can do slicing on the values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-obj docutils literal"><span class="pre">Tractogram</span></code></a>([streamlines,&nbsp;...])</td>
<td>Container for streamlines and their data information.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-obj docutils literal"><span class="pre">TractogramItem</span></code></a>(streamline,&nbsp;...)</td>
<td>Class containing information about one streamline.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.is_data_dict" title="nibabel.streamlines.tractogram.is_data_dict"><code class="xref py py-obj docutils literal"><span class="pre">is_data_dict</span></code></a>(obj)</td>
<td>True if <cite>obj</cite> seems to implement the <code class="xref py py-class docutils literal"><span class="pre">DataDict</span></code> API</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram.is_lazy_dict" title="nibabel.streamlines.tractogram.is_lazy_dict"><code class="xref py py-obj docutils literal"><span class="pre">is_lazy_dict</span></code></a>(obj)</td>
<td>True if <cite>obj</cite> seems to implement the <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal"><span class="pre">LazyDict</span></code></a> API</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.tractogram_file">
<span id="module-streamlines-tractogram-file"></span><h2>Module: <code class="xref py py-mod docutils literal"><span class="pre">streamlines.tractogram_file</span></code><a class="headerlink" href="#module-nibabel.streamlines.tractogram_file" title="Permalink to this headline">¶</a></h2>
<p>Define abstract interface for Tractogram file classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram_file.DataError" title="nibabel.streamlines.tractogram_file.DataError"><code class="xref py py-obj docutils literal"><span class="pre">DataError</span></code></a></td>
<td>Raised when data is missing or inconsistent in a tractogram file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram_file.ExtensionWarning" title="nibabel.streamlines.tractogram_file.ExtensionWarning"><code class="xref py py-obj docutils literal"><span class="pre">ExtensionWarning</span></code></a></td>
<td>Base class for warnings about tractogram file extension.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderError" title="nibabel.streamlines.tractogram_file.HeaderError"><code class="xref py py-obj docutils literal"><span class="pre">HeaderError</span></code></a></td>
<td>Raised when a tractogram file header contains invalid information.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderWarning" title="nibabel.streamlines.tractogram_file.HeaderWarning"><code class="xref py py-obj docutils literal"><span class="pre">HeaderWarning</span></code></a></td>
<td>Base class for warnings about tractogram file header.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-obj docutils literal"><span class="pre">TractogramFile</span></code></a>(tractogram[,&nbsp;header])</td>
<td>Convenience class to encapsulate tractogram file format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.tractogram_file.abstractclassmethod" title="nibabel.streamlines.tractogram_file.abstractclassmethod"><code class="xref py py-obj docutils literal"><span class="pre">abstractclassmethod</span></code></a>(callable)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.trk">
<span id="module-streamlines-trk"></span><h2>Module: <code class="xref py py-mod docutils literal"><span class="pre">streamlines.trk</span></code><a class="headerlink" href="#module-nibabel.streamlines.trk" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-obj docutils literal"><span class="pre">TrkFile</span></code></a>(tractogram[,&nbsp;header])</td>
<td>Convenience class to encapsulate TRK file format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.trk.create_empty_header" title="nibabel.streamlines.trk.create_empty_header"><code class="xref py py-obj docutils literal"><span class="pre">create_empty_header</span></code></a>()</td>
<td>Return an empty compliant TRK header.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.trk.decode_value_from_name" title="nibabel.streamlines.trk.decode_value_from_name"><code class="xref py py-obj docutils literal"><span class="pre">decode_value_from_name</span></code></a>(encoded_name)</td>
<td>Decodes a value that has been encoded in the last bytes of a string.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.trk.encode_value_in_name" title="nibabel.streamlines.trk.encode_value_in_name"><code class="xref py py-obj docutils literal"><span class="pre">encode_value_in_name</span></code></a>(value,&nbsp;name[,&nbsp;max_name_len])</td>
<td>Return <cite>name</cite> as fixed-length string, appending <cite>value</cite> as string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.trk.get_affine_rasmm_to_trackvis" title="nibabel.streamlines.trk.get_affine_rasmm_to_trackvis"><code class="xref py py-obj docutils literal"><span class="pre">get_affine_rasmm_to_trackvis</span></code></a>(header)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.streamlines.trk.get_affine_trackvis_to_rasmm" title="nibabel.streamlines.trk.get_affine_trackvis_to_rasmm"><code class="xref py py-obj docutils literal"><span class="pre">get_affine_trackvis_to_rasmm</span></code></a>(header)</td>
<td>Get affine mapping trackvis voxelmm space to RAS+ mm space</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.utils">
<span id="module-streamlines-utils"></span><h2>Module: <code class="xref py py-mod docutils literal"><span class="pre">streamlines.utils</span></code><a class="headerlink" href="#module-nibabel.streamlines.utils" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.streamlines.utils.get_affine_from_reference" title="nibabel.streamlines.utils.get_affine_from_reference"><code class="xref py py-obj docutils literal"><span class="pre">get_affine_from_reference</span></code></a>(ref)</td>
<td>Returns the affine defining the reference space.</td>
</tr>
</tbody>
</table>
<div class="section" id="detect-format">
<h3>detect_format<a class="headerlink" href="#detect-format" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.detect_format">
<code class="descclassname">nibabel.streamlines.</code><code class="descname">detect_format</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.detect_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the StreamlinesFile object guessed from the file-like object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object pointing
to a tractogram file (and ready to read from the beginning of the
header)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tractogram_file</strong> : <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> class</p>
<blockquote class="last">
<div><p>The class type guessed from the content of <cite>fileobj</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="is-supported">
<h3>is_supported<a class="headerlink" href="#is-supported" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.is_supported">
<code class="descclassname">nibabel.streamlines.</code><code class="descname">is_supported</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.is_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the file-like object if supported by NiBabel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object pointing
to a streamlines file (and ready to read from the beginning of the
header)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>is_supported</strong> : boolean</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="load">
<h3>load<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.load">
<code class="descclassname">nibabel.streamlines.</code><code class="descname">load</code><span class="sig-paren">(</span><em>fileobj</em>, <em>lazy_load=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines in <em>RAS+</em> and <em>mm</em> space from a file-like object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object
pointing to a streamlines file (and ready to read from the beginning
of the streamlines file&#8217;s header).</p>
</div></blockquote>
<p><strong>lazy_load</strong> : {False, True}, optional</p>
<blockquote>
<div><p>If True, load streamlines in a lazy manner i.e. they will not be kept
in memory and only be loaded when needed.
Otherwise, load all streamlines in memory.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tractogram_file</strong> : <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> object</p>
<blockquote class="last">
<div><p>Returns an instance of a <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> containing data and
metadata of the tractogram loaded from <cite>fileobj</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The streamline coordinate (0,0,0) refers to the center of the voxel.</p>
</dd></dl>

</div>
<div class="section" id="save">
<h3>save<a class="headerlink" href="#save" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.save">
<code class="descclassname">nibabel.streamlines.</code><code class="descname">save</code><span class="sig-paren">(</span><em>tractogram</em>, <em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a tractogram to a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tractogram</strong> : <code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code> object or <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> object</p>
<blockquote>
<div><p>If <code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code> object, the file format will be guessed from
<cite>filename</cite> and a <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> object will be created using
provided keyword arguments.
If <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> object, the file format is known and will
be used to save its content to <cite>filename</cite>.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of the file where the tractogram will be saved.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : keyword arguments</p>
<blockquote class="last">
<div><p>Keyword arguments passed to <code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code> constructor.
Should not be specified if <cite>tractogram</cite> is already an instance of
<code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="arraysequence">
<h3><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a><a class="headerlink" href="#arraysequence" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.array_sequence.ArraySequence">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.array_sequence.</code><code class="descname">ArraySequence</code><span class="sig-paren">(</span><em>iterable=None</em>, <em>buffer_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Sequence of ndarrays having variable first dimension sizes.</p>
<p>This is a container that can store multiple ndarrays where each ndarray
might have a different first dimension size but a <em>common</em> size for the
remaining dimensions.</p>
<p>More generally, an instance of <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> of length <span class="math">\(N\)</span> is
composed of <span class="math">\(N\)</span> ndarrays of shape <span class="math">\((d_1, d_2, ... d_D)\)</span> where <span class="math">\(d_1\)</span>
can vary in length between arrays but <span class="math">\((d_2, ..., d_D)\)</span> have to be the
same for every ndarray.</p>
<p>Initialize array sequence instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>iterable</strong> : None or iterable or <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a>, optional</p>
<blockquote>
<div><p>If None, create an empty <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object.
If iterable, create a <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object initialized
from array-like objects yielded by the iterable.
If <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a>, create a view (no memory is allocated).
For an actual copy use <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.copy" title="nibabel.streamlines.array_sequence.ArraySequence.copy"><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a> instead.</p>
</div></blockquote>
<p><strong>buffer_size</strong> : float, optional</p>
<blockquote class="last">
<div><p>Size (in Mb) for memory allocation when <cite>iterable</cite> is a generator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>iterable=None</em>, <em>buffer_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize array sequence instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>iterable</strong> : None or iterable or <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a>, optional</p>
<blockquote>
<div><p>If None, create an empty <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object.
If iterable, create a <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object initialized
from array-like objects yielded by the iterable.
If <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a>, create a view (no memory is allocated).
For an actual copy use <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.copy" title="nibabel.streamlines.array_sequence.ArraySequence.copy"><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a> instead.</p>
</div></blockquote>
<p><strong>buffer_size</strong> : float, optional</p>
<blockquote class="last">
<div><p>Size (in Mb) for memory allocation when <cite>iterable</cite> is a generator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>element</em>, <em>cache_build=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends <cite>element</cite> to this array sequence.</p>
<p>Append can be a lot faster if it knows that it is appending several
elements instead of a single element.  In that case it can cache the
parameters it uses between append operations, in a &#8220;build cache&#8221;.  To
tell append to do this, use <code class="docutils literal"><span class="pre">cache_build=True</span></code>.  If you use
<code class="docutils literal"><span class="pre">cache_build=True</span></code>, you need to finalize the append operations with
<a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.finalize_append" title="nibabel.streamlines.array_sequence.ArraySequence.finalize_append"><code class="xref py py-meth docutils literal"><span class="pre">finalize_append()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>element</strong> : ndarray</p>
<blockquote>
<div><p>Element to append. The shape must match already inserted elements
shape except for the first dimension.</p>
</div></blockquote>
<p><strong>cache_build</strong> : {False, True}</p>
<blockquote>
<div><p>Whether to save the build cache from this append routine.  If True,
append can assume it is the only player updating <cite>self</cite>, and the
caller must finalize <cite>self</cite> after all append operations, with
<code class="docutils literal"><span class="pre">self.finalize_append()</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If you need to add multiple elements you should consider
<cite>ArraySequence.extend</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.common_shape">
<code class="descname">common_shape</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.common_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Matching shape of the elements in this array sequence.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a copy of this <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>seq_copy</strong> : <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> instance</p>
<blockquote class="last">
<div><p>Copy of <cite>self</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We do not simply deepcopy this object because we have a chance to use
less memory. For example, if the array sequence being copied is the
result of a slicing operation on an array sequence.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.data">
<code class="descname">data</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Elements in this array sequence.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends all <cite>elements</cite> to this array sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elements</strong> : iterable of ndarrays or <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object</p>
<blockquote>
<div><p>If iterable of ndarrays, each ndarray will be concatenated along
the first dimension then appended to the data of this
ArraySequence.
If <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object, its data are simply appended to
the data of this ArraySequence.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The shape of the elements to be added must match the one of the data of
this <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> except for the first dimension.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.finalize_append">
<code class="descname">finalize_append</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.finalize_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize process of appending several elements to <cite>self</cite></p>
<p><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.append" title="nibabel.streamlines.array_sequence.ArraySequence.append"><code class="xref py py-meth docutils literal"><span class="pre">append()</span></code></a> can be a lot faster if it knows that it is appending
several elements instead of a single element.  To tell the append
method this is the case, use <code class="docutils literal"><span class="pre">cache_build=True</span></code>.  This method
finalizes the series of append operations after a call to
<a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.append" title="nibabel.streamlines.array_sequence.ArraySequence.append"><code class="xref py py-meth docutils literal"><span class="pre">append()</span></code></a> with <code class="docutils literal"><span class="pre">cache_build=True</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.is_array_sequence">
<code class="descname">is_array_sequence</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.is_array_sequence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object from a .npz file.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves this <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> object to a .npz file.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.shrink_data">
<code class="descname">shrink_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.shrink_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.total_nb_rows">
<code class="descname">total_nb_rows</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.total_nb_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of rows in this array sequence.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="create-arraysequences-from-generator">
<h3>create_arraysequences_from_generator<a class="headerlink" href="#create-arraysequences-from-generator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.create_arraysequences_from_generator">
<code class="descclassname">nibabel.streamlines.array_sequence.</code><code class="descname">create_arraysequences_from_generator</code><span class="sig-paren">(</span><em>gen</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.create_arraysequences_from_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code></a> objects from a generator yielding tuples</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator</p>
<blockquote>
<div><p>Generator yielding a size <cite>n</cite> tuple containing the values to put in the
array sequences.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote class="last">
<div><p>Number of <code class="xref py py-class docutils literal"><span class="pre">ArraySequences</span></code> object to create.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="is-array-sequence">
<h3>is_array_sequence<a class="headerlink" href="#is-array-sequence" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.is_array_sequence">
<code class="descclassname">nibabel.streamlines.array_sequence.</code><code class="descname">is_array_sequence</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.is_array_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if <cite>obj</cite> is an array sequence.</p>
</dd></dl>

</div>
<div class="section" id="is-ndarray-of-int-or-bool">
<h3>is_ndarray_of_int_or_bool<a class="headerlink" href="#is-ndarray-of-int-or-bool" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool">
<code class="descclassname">nibabel.streamlines.array_sequence.</code><code class="descname">is_ndarray_of_int_or_bool</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="field">
<h3><a class="reference internal" href="#nibabel.streamlines.header.Field" title="nibabel.streamlines.header.Field"><code class="xref py py-class docutils literal"><span class="pre">Field</span></code></a><a class="headerlink" href="#field" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.header.Field">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.header.</code><code class="descname">Field</code><a class="headerlink" href="#nibabel.streamlines.header.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Header fields common to multiple streamline file formats.</p>
<p>In IPython, use <cite>nibabel.streamlines.Field??</cite> to list them.</p>
<dl class="method">
<dt id="nibabel.streamlines.header.Field.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.header.Field.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.DIMENSIONS">
<code class="descname">DIMENSIONS</code><em class="property"> = 'dimensions'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.DIMENSIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.ENDIANNESS">
<code class="descname">ENDIANNESS</code><em class="property"> = 'endianness'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.ENDIANNESS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.MAGIC_NUMBER">
<code class="descname">MAGIC_NUMBER</code><em class="property"> = 'magic_number'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.MAGIC_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.METHOD">
<code class="descname">METHOD</code><em class="property"> = 'method'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.METHOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_POINTS">
<code class="descname">NB_POINTS</code><em class="property"> = 'nb_points'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_POINTS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_PROPERTIES_PER_STREAMLINE">
<code class="descname">NB_PROPERTIES_PER_STREAMLINE</code><em class="property"> = 'nb_properties_per_streamline'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_PROPERTIES_PER_STREAMLINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_SCALARS_PER_POINT">
<code class="descname">NB_SCALARS_PER_POINT</code><em class="property"> = 'nb_scalars_per_point'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_SCALARS_PER_POINT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_STREAMLINES">
<code class="descname">NB_STREAMLINES</code><em class="property"> = 'nb_streamlines'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_STREAMLINES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.ORIGIN">
<code class="descname">ORIGIN</code><em class="property"> = 'origin'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.ORIGIN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.STEP_SIZE">
<code class="descname">STEP_SIZE</code><em class="property"> = 'step_size'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.STEP_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.VOXEL_ORDER">
<code class="descname">VOXEL_ORDER</code><em class="property"> = 'voxel_order'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.VOXEL_ORDER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.VOXEL_SIZES">
<code class="descname">VOXEL_SIZES</code><em class="property"> = 'voxel_sizes'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.VOXEL_SIZES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.VOXEL_TO_RASMM">
<code class="descname">VOXEL_TO_RASMM</code><em class="property"> = 'voxel_to_rasmm'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.VOXEL_TO_RASMM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="lazydict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal"><span class="pre">LazyDict</span></code></a><a class="headerlink" href="#lazydict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.LazyDict">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">LazyDict</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_abcoll.MutableMapping</span></code></p>
<p>Dictionary of generator functions.</p>
<p>This container behaves like a dictionary but it makes sure its elements are
callable objects that it assumes are generator functions yielding values.
When getting the element associated with a given key, the element (i.e. a
generator function) is first called before being returned.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyDict.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="lazytractogram">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a><a class="headerlink" href="#lazytractogram" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.LazyTractogram">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">LazyTractogram</code><span class="sig-paren">(</span><em>streamlines=None</em>, <em>data_per_streamline=None</em>, <em>data_per_point=None</em>, <em>affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">nibabel.streamlines.tractogram.Tractogram</span></code></a></p>
<p>Lazy container for streamlines and their data information.</p>
<p>This container behaves lazily as it uses generator functions to manage
streamlines and their data information. This container is thus memory
friendly since it doesn&#8217;t require having all this data loaded in memory.</p>
<p>Streamlines of a lazy tractogram can be in any coordinate system of your
choice as long as you provide the correct <cite>affine_to_rasmm</cite> matrix, at
construction time, that brings the streamlines back to <em>RAS+</em>, <em>mm</em> space,
where the coordinates (0,0,0) corresponds to the center of the voxel
(as opposed to the corner of the voxel).</p>
<p class="rubric">Notes</p>
<p>LazyTractogram objects do not support indexing currently.
LazyTractogram objects are suited for operations that can be linearized
such as applying an affine transformation or converting streamlines from
one file format to another.</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>streamlines</td>
<td>(generator function) Generator function yielding streamlines. Each streamline is an ndarray of shape (<span class="math">\(N_t\)</span>, 3) where <span class="math">\(N_t\)</span> is the number of points of streamline <span class="math">\(t\)</span>.</td>
</tr>
<tr class="row-even"><td>data_per_streamline</td>
<td>(instance of <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal"><span class="pre">LazyDict</span></code></a>) Dictionary where the items are (str, instantiated generator). Each key represents a piece of information <span class="math">\(i\)</span> to be kept alongside every streamline, and its associated value is a generator function yielding that information via ndarrays of shape (<span class="math">\(P_i\)</span>,) where <span class="math">\(P_i\)</span> is the number of values to store for that particular piece of information <span class="math">\(i\)</span>.</td>
</tr>
<tr class="row-odd"><td>data_per_point</td>
<td>(<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal"><span class="pre">LazyDict</span></code></a> object) Dictionary where the items are (str, instantiated generator).  Each key represents a piece of information <span class="math">\(i\)</span> to be kept alongside every point of every streamline, and its associated value is a generator function yielding that information via ndarrays of shape (<span class="math">\(N_t\)</span>, <span class="math">\(M_i\)</span>) where <span class="math">\(N_t\)</span> is the number of points for a particular streamline <span class="math">\(t\)</span> and <span class="math">\(M_i\)</span> is the number of values to store for that particular piece of information <span class="math">\(i\)</span>.</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>streamlines</strong> : generator function, optional</p>
<blockquote>
<div><p>Generator function yielding streamlines. Each streamline is an
ndarray of shape (<span class="math">\(N_t\)</span>, 3) where <span class="math">\(N_t\)</span> is the number of points of
streamline <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>data_per_streamline</strong> : dict of generator functions, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
streamline, and its associated value is a generator function
yielding that information via ndarrays of shape (<span class="math">\(P_i\)</span>,) where
<span class="math">\(P_i\)</span> is the number of values to store for that particular
information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>data_per_point</strong> : dict of generator functions, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is a generator
function yielding that information via ndarrays of shape
(<span class="math">\(N_t\)</span>, <span class="math">\(M_i\)</span>) where <span class="math">\(N_t\)</span> is the number of points for a particular
streamline <span class="math">\(t\)</span> and <span class="math">\(M_i\)</span> is the number of values to store for
that particular information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>affine_to_rasmm</strong> : ndarray of shape (4, 4) or None, optional</p>
<blockquote class="last">
<div><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>streamlines=None</em>, <em>data_per_streamline=None</em>, <em>data_per_point=None</em>, <em>affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>streamlines</strong> : generator function, optional</p>
<blockquote>
<div><p>Generator function yielding streamlines. Each streamline is an
ndarray of shape (<span class="math">\(N_t\)</span>, 3) where <span class="math">\(N_t\)</span> is the number of points of
streamline <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>data_per_streamline</strong> : dict of generator functions, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
streamline, and its associated value is a generator function
yielding that information via ndarrays of shape (<span class="math">\(P_i\)</span>,) where
<span class="math">\(P_i\)</span> is the number of values to store for that particular
information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>data_per_point</strong> : dict of generator functions, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is a generator
function yielding that information via ndarrays of shape
(<span class="math">\(N_t\)</span>, <span class="math">\(M_i\)</span>) where <span class="math">\(N_t\)</span> is the number of points for a particular
streamline <span class="math">\(t\)</span> and <span class="math">\(M_i\)</span> is the number of values to store for
that particular information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>affine_to_rasmm</strong> : ndarray of shape (4, 4) or None, optional</p>
<blockquote class="last">
<div><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.apply_affine">
<code class="descname">apply_affine</code><span class="sig-paren">(</span><em>affine</em>, <em>lazy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an affine transformation to the streamlines.</p>
<p>The transformation given by the <cite>affine</cite> matrix is applied after any
other pending transformations to the streamline points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>affine</strong> : 2D array (4,4)</p>
<blockquote>
<div><p>Transformation matrix that will be applied on each streamline.</p>
</div></blockquote>
<p><strong>lazy</strong> : True, optional</p>
<blockquote>
<div><p>Should always be True for <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object. Doing
otherwise will raise a ValueError.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lazy_tractogram</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object</p>
<blockquote class="last">
<div><p>A copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> instance but with a
transformation to be applied on the streamlines.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.data">
<code class="descname">data</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.data_per_point">
<code class="descname">data_per_point</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.data_per_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.data_per_streamline">
<code class="descname">data_per_streamline</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.data_per_streamline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.from_data_func">
<em class="property">classmethod </em><code class="descname">from_data_func</code><span class="sig-paren">(</span><em>data_func</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.from_data_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an instance from a generator function.</p>
<p>The generator function must yield <a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal"><span class="pre">TractogramItem</span></code></a> objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data_func</strong> : generator function yielding <a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal"><span class="pre">TractogramItem</span></code></a> objects</p>
<blockquote>
<div><p>Generator function that whenever is called starts yielding
<a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal"><span class="pre">TractogramItem</span></code></a> objects that will be used to instantiate a
<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lazy_tractogram</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object</p>
<blockquote class="last">
<div><p>New lazy tractogram.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.from_tractogram">
<em class="property">classmethod </em><code class="descname">from_tractogram</code><span class="sig-paren">(</span><em>tractogram</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.from_tractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object from a <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tractogram</strong> : <code class="xref py py-class docutils literal"><span class="pre">Tractgogram</span></code> object</p>
<blockquote>
<div><p>Tractogram from which to create a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lazy_tractogram</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object</p>
<blockquote class="last">
<div><p>New lazy tractogram.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.streamlines">
<code class="descname">streamlines</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.streamlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.to_world">
<code class="descname">to_world</code><span class="sig-paren">(</span><em>lazy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.to_world" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings the streamlines to world space (i.e. RAS+ and mm).</p>
<p>The transformation is applied after any other pending transformations
to the streamline points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>lazy</strong> : True, optional</p>
<blockquote>
<div><p>Should always be True for <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object. Doing
otherwise will raise a ValueError.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lazy_tractogram</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object</p>
<blockquote class="last">
<div><p>A copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> instance but with a
transformation to be applied on the streamlines.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="perarraydict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal"><span class="pre">PerArrayDict</span></code></a><a class="headerlink" href="#perarraydict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.PerArrayDict">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">PerArrayDict</code><span class="sig-paren">(</span><em>n_rows=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArrayDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="nibabel.streamlines.tractogram.SliceableDataDict"><code class="xref py py-class docutils literal"><span class="pre">nibabel.streamlines.tractogram.SliceableDataDict</span></code></a></p>
<p>Dictionary for which key access can do slicing on the values.</p>
<p>This container behaves like a standard dictionary but extends key access to
allow keys for key access to be indices slicing into the contained ndarray
values.  The elements must also be ndarrays.</p>
<p>In addition, it makes sure the amount of data contained in those ndarrays
matches the number of streamlines given at the instantiation of this
instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_rows</strong> : None or int, optional</p>
<blockquote>
<div><p>Number of rows per value in each key, value pair or None for not
specified.</p>
</div></blockquote>
<p><strong>*args :</strong></p>
<p><strong>**kwargs :</strong></p>
<blockquote class="last">
<div><p>Positional and keyword arguments, passed straight through the <code class="docutils literal"><span class="pre">dict</span></code>
constructor.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.PerArrayDict.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>n_rows=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArrayDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="perarraysequencedict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="nibabel.streamlines.tractogram.PerArraySequenceDict"><code class="xref py py-class docutils literal"><span class="pre">PerArraySequenceDict</span></code></a><a class="headerlink" href="#perarraysequencedict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.PerArraySequenceDict">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">PerArraySequenceDict</code><span class="sig-paren">(</span><em>n_rows=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal"><span class="pre">nibabel.streamlines.tractogram.PerArrayDict</span></code></a></p>
<p>Dictionary for which key access can do slicing on the values.</p>
<p>This container behaves like a standard dictionary but extends key access to
allow keys for key access to be indices slicing into the contained ndarray
values.  The elements must also be <code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code>.</p>
<p>In addition, it makes sure the amount of data contained in those array
sequences matches the number of elements given at the instantiation
of the instance.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.PerArraySequenceDict.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>n_rows=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArraySequenceDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="sliceabledatadict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="nibabel.streamlines.tractogram.SliceableDataDict"><code class="xref py py-class docutils literal"><span class="pre">SliceableDataDict</span></code></a><a class="headerlink" href="#sliceabledatadict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.SliceableDataDict">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">SliceableDataDict</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_abcoll.MutableMapping</span></code></p>
<p>Dictionary for which key access can do slicing on the values.</p>
<p>This container behaves like a standard dictionary but extends key access to
allow keys for key access to be indices slicing into the contained ndarray
values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>*args :</strong></p>
<p><strong>**kwargs :</strong></p>
<blockquote class="last">
<div><p>Positional and keyword arguments, passed straight through the <code class="docutils literal"><span class="pre">dict</span></code>
constructor.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.SliceableDataDict.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.SliceableDataDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="tractogram">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a><a class="headerlink" href="#tractogram" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.Tractogram">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">Tractogram</code><span class="sig-paren">(</span><em>streamlines=None</em>, <em>data_per_streamline=None</em>, <em>data_per_point=None</em>, <em>affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Container for streamlines and their data information.</p>
<p>Streamlines of a tractogram can be in any coordinate system of your
choice as long as you provide the correct <cite>affine_to_rasmm</cite> matrix, at
construction time, that brings the streamlines back to <em>RAS+</em>, <em>mm</em> space,
where the coordinates (0,0,0) corresponds to the center of the voxel
(as opposed to the corner of the voxel).</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>streamlines</td>
<td>(<code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code> object) Sequence of <span class="math">\(T\)</span> streamlines. Each streamline is an ndarray of shape (<span class="math">\(N_t\)</span>, 3) where <span class="math">\(N_t\)</span> is the number of points of streamline <span class="math">\(t\)</span>.</td>
</tr>
<tr class="row-even"><td>data_per_streamline</td>
<td>(<a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal"><span class="pre">PerArrayDict</span></code></a> object) Dictionary where the items are (str, 2D array).  Each key represents a piece of information <span class="math">\(i\)</span> to be kept alongside every streamline, and its associated value is a 2D array of shape (<span class="math">\(T\)</span>, <span class="math">\(P_i\)</span>) where <span class="math">\(T\)</span> is the number of streamlines and <span class="math">\(P_i\)</span> is the number of values to store for that particular piece of information <span class="math">\(i\)</span>.</td>
</tr>
<tr class="row-odd"><td>data_per_point</td>
<td>(<a class="reference internal" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="nibabel.streamlines.tractogram.PerArraySequenceDict"><code class="xref py py-class docutils literal"><span class="pre">PerArraySequenceDict</span></code></a> object) Dictionary where the items are (str, <code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code>).  Each key represents a piece of information <span class="math">\(i\)</span> to be kept alongside every point of every streamline, and its associated value is an iterable of ndarrays of shape (<span class="math">\(N_t\)</span>, <span class="math">\(M_i\)</span>) where <span class="math">\(N_t\)</span> is the number of points for a particular streamline <span class="math">\(t\)</span> and <span class="math">\(M_i\)</span> is the number values to store for that particular piece of information <span class="math">\(i\)</span>.</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>streamlines</strong> : iterable of ndarrays or <code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code>, optional</p>
<blockquote>
<div><p>Sequence of <span class="math">\(T\)</span> streamlines. Each streamline is an ndarray of
shape (<span class="math">\(N_t\)</span>, 3) where <span class="math">\(N_t\)</span> is the number of points of
streamline <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>data_per_streamline</strong> : dict of iterable of ndarrays, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
streamline, and its associated value is an iterable of ndarrays of
shape (<span class="math">\(P_i\)</span>,) where <span class="math">\(P_i\)</span> is the number of scalar values to store
for that particular information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>data_per_point</strong> : dict of iterable of ndarrays, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is an iterable
of ndarrays of shape (<span class="math">\(N_t\)</span>, <span class="math">\(M_i\)</span>) where <span class="math">\(N_t\)</span> is the number of
points for a particular streamline <span class="math">\(t\)</span> and <span class="math">\(M_i\)</span> is the number
scalar values to store for that particular information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>affine_to_rasmm</strong> : ndarray of shape (4, 4) or None, optional</p>
<blockquote class="last">
<div><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>streamlines=None</em>, <em>data_per_streamline=None</em>, <em>data_per_point=None</em>, <em>affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>streamlines</strong> : iterable of ndarrays or <code class="xref py py-class docutils literal"><span class="pre">ArraySequence</span></code>, optional</p>
<blockquote>
<div><p>Sequence of <span class="math">\(T\)</span> streamlines. Each streamline is an ndarray of
shape (<span class="math">\(N_t\)</span>, 3) where <span class="math">\(N_t\)</span> is the number of points of
streamline <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>data_per_streamline</strong> : dict of iterable of ndarrays, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
streamline, and its associated value is an iterable of ndarrays of
shape (<span class="math">\(P_i\)</span>,) where <span class="math">\(P_i\)</span> is the number of scalar values to store
for that particular information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>data_per_point</strong> : dict of iterable of ndarrays, optional</p>
<blockquote>
<div><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is an iterable
of ndarrays of shape (<span class="math">\(N_t\)</span>, <span class="math">\(M_i\)</span>) where <span class="math">\(N_t\)</span> is the number of
points for a particular streamline <span class="math">\(t\)</span> and <span class="math">\(M_i\)</span> is the number
scalar values to store for that particular information <span class="math">\(i\)</span>.</p>
</div></blockquote>
<p><strong>affine_to_rasmm</strong> : ndarray of shape (4, 4) or None, optional</p>
<blockquote class="last">
<div><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.Tractogram.affine_to_rasmm">
<code class="descname">affine_to_rasmm</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.affine_to_rasmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Affine bringing streamlines in this tractogram to RAS+mm.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.apply_affine">
<code class="descname">apply_affine</code><span class="sig-paren">(</span><em>affine</em>, <em>lazy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an affine transformation on the points of each streamline.</p>
<p>If <cite>lazy</cite> is not specified, this is performed <em>in-place</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>affine</strong> : ndarray of shape (4, 4)</p>
<blockquote>
<div><p>Transformation that will be applied to every streamline.</p>
</div></blockquote>
<p><strong>lazy</strong> : {False, True}, optional</p>
<blockquote>
<div><p>If True, streamlines are <em>not</em> transformed in-place and a
<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object is returned. Otherwise, streamlines
are modified in-place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tractogram</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a> or <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object</p>
<blockquote class="last">
<div><p>Tractogram where the streamlines have been transformed according
to the given affine transformation. If the <cite>lazy</cite> option is true,
it returns a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object, otherwise it returns a
reference to this <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a> object with updated
streamlines.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a> object.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.Tractogram.data_per_point">
<code class="descname">data_per_point</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.data_per_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.Tractogram.data_per_streamline">
<code class="descname">data_per_streamline</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.data_per_streamline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram.Tractogram.streamlines">
<code class="descname">streamlines</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.streamlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.to_world">
<code class="descname">to_world</code><span class="sig-paren">(</span><em>lazy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.to_world" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings the streamlines to world space (i.e. RAS+ and mm).</p>
<p>If <cite>lazy</cite> is not specified, this is performed <em>in-place</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>lazy</strong> : {False, True}, optional</p>
<blockquote>
<div><p>If True, streamlines are <em>not</em> transformed in-place and a
<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object is returned. Otherwise, streamlines
are modified in-place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tractogram</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a> or <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a> object</p>
<blockquote class="last">
<div><p>Tractogram where the streamlines have been sent to world space.
If the <cite>lazy</cite> option is true, it returns a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal"><span class="pre">LazyTractogram</span></code></a>
object, otherwise it returns a reference to this
<a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code></a> object with updated streamlines.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tractogramitem">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal"><span class="pre">TractogramItem</span></code></a><a class="headerlink" href="#tractogramitem" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.TractogramItem">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">TractogramItem</code><span class="sig-paren">(</span><em>streamline</em>, <em>data_for_streamline</em>, <em>data_for_points</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.TractogramItem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class containing information about one streamline.</p>
<p><a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal"><span class="pre">TractogramItem</span></code></a> objects have three public attributes: <cite>streamline</cite>,
<cite>data_for_streamline</cite>, and <cite>data_for_points</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>streamline</strong> : ndarray shape (N, 3)</p>
<blockquote>
<div><p>Points of this streamline represented as an ndarray of shape (N, 3)
where N is the number of points.</p>
</div></blockquote>
<p><strong>data_for_streamline</strong> : dict</p>
<blockquote>
<div><p>Dictionary containing some data associated with this particular
streamline. Each key <code class="docutils literal"><span class="pre">k</span></code> is mapped to a ndarray of shape (Pt,), where
<code class="docutils literal"><span class="pre">Pt</span></code> is the dimension of the data associated with key <code class="docutils literal"><span class="pre">k</span></code>.</p>
</div></blockquote>
<p><strong>data_for_points</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary containing some data associated to each point of this
particular streamline. Each key <code class="docutils literal"><span class="pre">k</span></code> is mapped to a ndarray of shape
(Nt, Mk), where <code class="docutils literal"><span class="pre">Nt</span></code> is the number of points of this streamline and
<code class="docutils literal"><span class="pre">Mk</span></code> is the dimension of the data associated with key <code class="docutils literal"><span class="pre">k</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.TractogramItem.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>streamline</em>, <em>data_for_streamline</em>, <em>data_for_points</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.TractogramItem.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="is-data-dict">
<h3>is_data_dict<a class="headerlink" href="#is-data-dict" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.tractogram.is_data_dict">
<code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">is_data_dict</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.is_data_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>obj</cite> seems to implement the <code class="xref py py-class docutils literal"><span class="pre">DataDict</span></code> API</p>
</dd></dl>

</div>
<div class="section" id="is-lazy-dict">
<h3>is_lazy_dict<a class="headerlink" href="#is-lazy-dict" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.tractogram.is_lazy_dict">
<code class="descclassname">nibabel.streamlines.tractogram.</code><code class="descname">is_lazy_dict</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.is_lazy_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>obj</cite> seems to implement the <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal"><span class="pre">LazyDict</span></code></a> API</p>
</dd></dl>

</div>
<div class="section" id="dataerror">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.DataError" title="nibabel.streamlines.tractogram_file.DataError"><code class="xref py py-class docutils literal"><span class="pre">DataError</span></code></a><a class="headerlink" href="#dataerror" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.DataError">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram_file.</code><code class="descname">DataError</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.DataError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Raised when data is missing or inconsistent in a tractogram file.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.DataError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.DataError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="extensionwarning">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.ExtensionWarning" title="nibabel.streamlines.tractogram_file.ExtensionWarning"><code class="xref py py-class docutils literal"><span class="pre">ExtensionWarning</span></code></a><a class="headerlink" href="#extensionwarning" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.ExtensionWarning">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram_file.</code><code class="descname">ExtensionWarning</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.ExtensionWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Base class for warnings about tractogram file extension.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.ExtensionWarning.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.ExtensionWarning.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="headererror">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderError" title="nibabel.streamlines.tractogram_file.HeaderError"><code class="xref py py-class docutils literal"><span class="pre">HeaderError</span></code></a><a class="headerlink" href="#headererror" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.HeaderError">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram_file.</code><code class="descname">HeaderError</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Raised when a tractogram file header contains invalid information.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.HeaderError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="headerwarning">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderWarning" title="nibabel.streamlines.tractogram_file.HeaderWarning"><code class="xref py py-class docutils literal"><span class="pre">HeaderWarning</span></code></a><a class="headerlink" href="#headerwarning" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.HeaderWarning">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram_file.</code><code class="descname">HeaderWarning</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></code></p>
<p>Base class for warnings about tractogram file header.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.HeaderWarning.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderWarning.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tractogramfile">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code></a><a class="headerlink" href="#tractogramfile" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram_file.</code><code class="descname">TractogramFile</code><span class="sig-paren">(</span><em>tractogram</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">abc.NewBase</span></code></p>
<p>Convenience class to encapsulate tractogram file format.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tractogram</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.affine">
<code class="descname">affine</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>voxmm -&gt; rasmm affine.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.header">
<code class="descname">header</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.is_correct_format">
<em class="property">classmethod </em><code class="descname">is_correct_format</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.is_correct_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the file has the right streamlines file format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object
pointing to a streamlines file (and ready to read from the
beginning of the header).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_correct_format</strong> : {True, False}</p>
<blockquote class="last">
<div><p>Returns True if <cite>fileobj</cite> is in the right streamlines file format,
otherwise returns False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>fileobj</em>, <em>lazy_load=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines from a filename or file-like object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object
pointing to a streamlines file (and ready to read from the
beginning of the header).</p>
</div></blockquote>
<p><strong>lazy_load</strong> : {False, True}, optional</p>
<blockquote>
<div><p>If True, load streamlines in a lazy manner i.e. they will not be
kept in memory. Otherwise, load all streamlines in memory.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tractogram_file</strong> : <a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal"><span class="pre">TractogramFile</span></code></a> object</p>
<blockquote class="last">
<div><p>Returns an object containing tractogram data and header
information.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves streamlines to a filename or file-like object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote class="last">
<div><p>If string, a filename; otherwise an open file-like object
opened and ready to write.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.streamlines">
<code class="descname">streamlines</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.streamlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.tractogram">
<code class="descname">tractogram</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.tractogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="abstractclassmethod">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.abstractclassmethod" title="nibabel.streamlines.tractogram_file.abstractclassmethod"><code class="xref py py-class docutils literal"><span class="pre">abstractclassmethod</span></code></a><a class="headerlink" href="#abstractclassmethod" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.abstractclassmethod">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.tractogram_file.</code><code class="descname">abstractclassmethod</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.abstractclassmethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">classmethod</span></code></p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.abstractclassmethod.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.abstractclassmethod.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="trkfile">
<h3><a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal"><span class="pre">TrkFile</span></code></a><a class="headerlink" href="#trkfile" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.trk.TrkFile">
<em class="property">class </em><code class="descclassname">nibabel.streamlines.trk.</code><code class="descname">TrkFile</code><span class="sig-paren">(</span><em>tractogram</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal"><span class="pre">nibabel.streamlines.tractogram_file.TractogramFile</span></code></a></p>
<p>Convenience class to encapsulate TRK file format.</p>
<p class="rubric">Notes</p>
<p>TrackVis (so its file format: TRK) considers the streamline coordinate
(0,0,0) to be in the corner of the voxel whereas NiBabel&#8217;s streamlines
internal representation (Voxel space) assumes (0,0,0) to be in the
center of the voxel.</p>
<p>Thus, streamlines are shifted by half a voxel on load and are shifted
back on save.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tractogram</strong> : <code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code> object</p>
<blockquote>
<div><p>Tractogram that will be contained in this <a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal"><span class="pre">TrkFile</span></code></a>.</p>
</div></blockquote>
<p><strong>header</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Metadata associated to this tractogram file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em>
and <em>mm</em> space where coordinate (0,0,0) refers to the center
of the voxel.</p>
<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tractogram</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tractogram</strong> : <code class="xref py py-class docutils literal"><span class="pre">Tractogram</span></code> object</p>
<blockquote>
<div><p>Tractogram that will be contained in this <a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal"><span class="pre">TrkFile</span></code></a>.</p>
</div></blockquote>
<p><strong>header</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Metadata associated to this tractogram file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em>
and <em>mm</em> space where coordinate (0,0,0) refers to the center
of the voxel.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.HEADER_SIZE">
<code class="descname">HEADER_SIZE</code><em class="property"> = 1000</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.HEADER_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.MAGIC_NUMBER">
<code class="descname">MAGIC_NUMBER</code><em class="property"> = 'TRACK'</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.MAGIC_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_POINT">
<code class="descname">SUPPORTS_DATA_PER_POINT</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_POINT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_STREAMLINE">
<code class="descname">SUPPORTS_DATA_PER_STREAMLINE</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_STREAMLINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.trk.TrkFile.is_correct_format">
<em class="property">classmethod </em><code class="descname">is_correct_format</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.is_correct_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the file is in TRK format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object
pointing to TRK file (and ready to read from the beginning
of the TRK header data). Note that calling this function
does not change the file position.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_correct_format</strong> : {True, False}</p>
<blockquote class="last">
<div><p>Returns True if <cite>fileobj</cite> is compatible with TRK format,
otherwise returns False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.streamlines.trk.TrkFile.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>fileobj</em>, <em>lazy_load=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines from a filename or file-like object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object
pointing to TRK file (and ready to read from the beginning
of the TRK header). Note that calling this function
does not change the file position.</p>
</div></blockquote>
<p><strong>lazy_load</strong> : {False, True}, optional</p>
<blockquote>
<div><p>If True, load streamlines in a lazy manner i.e. they will not be
kept in memory. Otherwise, load all streamlines in memory.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>trk_file</strong> : <a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal"><span class="pre">TrkFile</span></code></a> object</p>
<blockquote class="last">
<div><p>Returns an object containing tractogram data and header
information.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Streamlines of the returned tractogram are assumed to be in <em>RAS</em>
and <em>mm</em> space where coordinate (0,0,0) refers to the center of the
voxel.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save tractogram to a filename or file-like object using TRK format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote class="last">
<div><p>If string, a filename; otherwise an open file-like object
pointing to TRK file (and ready to write from the beginning
of the TRK header data).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="create-empty-header">
<h3>create_empty_header<a class="headerlink" href="#create-empty-header" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.create_empty_header">
<code class="descclassname">nibabel.streamlines.trk.</code><code class="descname">create_empty_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.create_empty_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty compliant TRK header.</p>
</dd></dl>

</div>
<div class="section" id="decode-value-from-name">
<h3>decode_value_from_name<a class="headerlink" href="#decode-value-from-name" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.decode_value_from_name">
<code class="descclassname">nibabel.streamlines.trk.</code><code class="descname">decode_value_from_name</code><span class="sig-paren">(</span><em>encoded_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.decode_value_from_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a value that has been encoded in the last bytes of a string.</p>
<p>Check <a class="reference internal" href="#nibabel.streamlines.trk.encode_value_in_name" title="nibabel.streamlines.trk.encode_value_in_name"><code class="xref py py-func docutils literal"><span class="pre">encode_value_in_name()</span></code></a> to see how the value has been encoded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>encoded_name</strong> : bytes</p>
<blockquote>
<div><p>Name in which a value has been encoded or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>name</strong> : bytes</p>
<blockquote>
<div><p>Name without the encoded value.</p>
</div></blockquote>
<p><strong>value</strong> : int</p>
<blockquote class="last">
<div><p>Value decoded from the name.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="encode-value-in-name">
<h3>encode_value_in_name<a class="headerlink" href="#encode-value-in-name" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.encode_value_in_name">
<code class="descclassname">nibabel.streamlines.trk.</code><code class="descname">encode_value_in_name</code><span class="sig-paren">(</span><em>value</em>, <em>name</em>, <em>max_name_len=20</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.encode_value_in_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>name</cite> as fixed-length string, appending <cite>value</cite> as string.</p>
<p>Form output from <cite>name</cite> if <cite>value &lt;= 1</cite> else <cite>name</cite> + <code class="docutils literal"><span class="pre">\</span></code> +
str(value).</p>
<p>Return output as fixed length string length <cite>max_name_len</cite>, padded with
<code class="docutils literal"><span class="pre">\</span></code>.</p>
<p>This function also verifies that the modified length of name is less than
<cite>max_name_len</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : int</p>
<blockquote>
<div><p>Integer value to encode.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>Name to which we may append an ascii / latin-1 representation of
<cite>value</cite>.</p>
</div></blockquote>
<p><strong>max_name_len</strong> : int, optional</p>
<blockquote>
<div><p>Maximum length of byte string that output can have.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>encoded_name</strong> : bytes</p>
<blockquote class="last">
<div><p>Name maybe followed by <code class="docutils literal"><span class="pre">\</span></code> and ascii / latin-1 representation of
<cite>value</cite>, padded with <code class="docutils literal"><span class="pre">\</span></code> bytes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="get-affine-rasmm-to-trackvis">
<h3>get_affine_rasmm_to_trackvis<a class="headerlink" href="#get-affine-rasmm-to-trackvis" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.get_affine_rasmm_to_trackvis">
<code class="descclassname">nibabel.streamlines.trk.</code><code class="descname">get_affine_rasmm_to_trackvis</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.get_affine_rasmm_to_trackvis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="get-affine-trackvis-to-rasmm">
<h3>get_affine_trackvis_to_rasmm<a class="headerlink" href="#get-affine-trackvis-to-rasmm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.get_affine_trackvis_to_rasmm">
<code class="descclassname">nibabel.streamlines.trk.</code><code class="descname">get_affine_trackvis_to_rasmm</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.get_affine_trackvis_to_rasmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get affine mapping trackvis voxelmm space to RAS+ mm space</p>
<p>The streamlines in a trackvis file are in &#8216;voxelmm&#8217; space, where the
coordinates refer to the corner of the voxel.</p>
<p>Compute the affine matrix that will bring them back to RAS+ mm space, where
the coordinates refer to the center of the voxel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>header</strong> : dict</p>
<blockquote>
<div><p>Dict containing trackvis header.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aff_tv2ras</strong> : shape (4, 4) array</p>
<blockquote class="last">
<div><p>Affine array mapping coordinates in &#8216;voxelmm&#8217; space to RAS+ mm space.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="get-affine-from-reference">
<h3>get_affine_from_reference<a class="headerlink" href="#get-affine-from-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.utils.get_affine_from_reference">
<code class="descclassname">nibabel.streamlines.utils.</code><code class="descname">get_affine_from_reference</code><span class="sig-paren">(</span><em>ref</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.utils.get_affine_from_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the affine defining the reference space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : str or <code class="xref py py-class docutils literal"><span class="pre">Nifti1Image</span></code> object or ndarray shape (4, 4)</p>
<blockquote>
<div><p>If str then it&#8217;s the filename of reference file that will be loaded
using <code class="xref py py-func docutils literal"><span class="pre">nibabel.load()</span></code> in order to obtain the affine.
If <code class="xref py py-class docutils literal"><span class="pre">Nifti1Image</span></code> object then the affine is obtained from it.
If ndarray shape (4, 4) then it&#8217;s the affine.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>affine</strong> : ndarray (4, 4)</p>
<blockquote class="last">
<div><p>Transformation matrix mapping voxel space to RAS+mm space.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2016, Matthew Brett, Michael Hanke, Eric Larson, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>