<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &#8212; NiBabel 2.1.1dev documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.1.1dev documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="batteryrunners" href="nibabel.batteryrunners.html" />
    <link rel="prev" title="arrayproxy" href="nibabel.arrayproxy.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.batteryrunners.html" title="batteryrunners"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.arrayproxy.html" title="arrayproxy"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">affines</span></code></a><ul>
<li><a class="reference internal" href="#affineerror"><code class="docutils literal"><span class="pre">AffineError</span></code></a></li>
<li><a class="reference internal" href="#append-diag">append_diag</a></li>
<li><a class="reference internal" href="#apply-affine">apply_affine</a></li>
<li><a class="reference internal" href="#dot-reduce">dot_reduce</a></li>
<li><a class="reference internal" href="#from-matvec">from_matvec</a></li>
<li><a class="reference internal" href="#to-matvec">to_matvec</a></li>
<li><a class="reference internal" href="#voxel-sizes">voxel_sizes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.arrayproxy.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">arrayproxy</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.batteryrunners.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">batteryrunners</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.affines.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.affines">
<span id="affines"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">affines</span></code><a class="headerlink" href="#module-nibabel.affines" title="Permalink to this headline">¶</a></h1>
<p>Utility routines for working with points and affine transforms</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.affines.AffineError" title="nibabel.affines.AffineError"><code class="xref py py-obj docutils literal"><span class="pre">AffineError</span></code></a></td>
<td>Errors in calculating or using affines</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.affines.append_diag" title="nibabel.affines.append_diag"><code class="xref py py-obj docutils literal"><span class="pre">append_diag</span></code></a>(aff,&nbsp;steps[,&nbsp;starts])</td>
<td>Add diagonal elements <cite>steps</cite> and translations <cite>starts</cite> to affine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.affines.apply_affine" title="nibabel.affines.apply_affine"><code class="xref py py-obj docutils literal"><span class="pre">apply_affine</span></code></a>(aff,&nbsp;pts)</td>
<td>Apply affine matrix <cite>aff</cite> to points <cite>pts</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.affines.dot_reduce" title="nibabel.affines.dot_reduce"><code class="xref py py-obj docutils literal"><span class="pre">dot_reduce</span></code></a>(*args)</td>
<td>Apply numpy dot product function from right to left on arrays</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.affines.from_matvec" title="nibabel.affines.from_matvec"><code class="xref py py-obj docutils literal"><span class="pre">from_matvec</span></code></a>(matrix[,&nbsp;vector])</td>
<td>Combine a matrix and vector into an homogeneous affine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.affines.to_matvec" title="nibabel.affines.to_matvec"><code class="xref py py-obj docutils literal"><span class="pre">to_matvec</span></code></a>(transform)</td>
<td>Split a transform into its matrix and vector components.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.affines.voxel_sizes" title="nibabel.affines.voxel_sizes"><code class="xref py py-obj docutils literal"><span class="pre">voxel_sizes</span></code></a>(affine)</td>
<td>Return voxel size for each input axis given <cite>affine</cite></td>
</tr>
</tbody>
</table>
<div class="section" id="affineerror">
<h2><a class="reference internal" href="#nibabel.affines.AffineError" title="nibabel.affines.AffineError"><code class="xref py py-class docutils literal"><span class="pre">AffineError</span></code></a><a class="headerlink" href="#affineerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.affines.AffineError">
<em class="property">class </em><code class="descclassname">nibabel.affines.</code><code class="descname">AffineError</code><a class="headerlink" href="#nibabel.affines.AffineError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></code></p>
<p>Errors in calculating or using affines</p>
<dl class="method">
<dt id="nibabel.affines.AffineError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.AffineError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="append-diag">
<h2>append_diag<a class="headerlink" href="#append-diag" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.affines.append_diag">
<code class="descclassname">nibabel.affines.</code><code class="descname">append_diag</code><span class="sig-paren">(</span><em>aff</em>, <em>steps</em>, <em>starts=()</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.append_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Add diagonal elements <cite>steps</cite> and translations <cite>starts</cite> to affine</p>
<p>Typical use is in expanding 4x4 affines to larger dimensions.  Nipy is the
main consumer because it uses NxM affines, whereas we generally only use
4x4 affines; the routine is here for convenience.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>aff</strong> : 2D array</p>
<blockquote>
<div><p>N by M affine matrix</p>
</div></blockquote>
<p><strong>steps</strong> : scalar or sequence</p>
<blockquote>
<div><p>diagonal elements to append.</p>
</div></blockquote>
<p><strong>starts</strong> : scalar or sequence</p>
<blockquote>
<div><p>elements to append to last column of <cite>aff</cite>, representing translations
corresponding to the <cite>steps</cite>. If empty, expands to a vector of zeros
of the same length as <cite>steps</cite></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aff_plus</strong> : 2D array</p>
<blockquote class="last">
<div><p>Now P by Q where L = <code class="docutils literal"><span class="pre">len(steps)</span></code> and P == N+L, Q=N+L</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">append_diag</span><span class="p">(</span><span class="n">aff</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">99</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="go">array([[   0.,    1.,    2.,    0.,    0.,    0.],</span>
<span class="go">       [   3.,    4.,    5.,    0.,    0.,    0.],</span>
<span class="go">       [   6.,    7.,    8.,    0.,    0.,    0.],</span>
<span class="go">       [   0.,    0.,    0.,    9.,    0.,   99.],</span>
<span class="go">       [   0.,    0.,    0.,    0.,   10.,  100.],</span>
<span class="go">       [   0.,    0.,    0.,    0.,    0.,    1.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="apply-affine">
<h2>apply_affine<a class="headerlink" href="#apply-affine" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.affines.apply_affine">
<code class="descclassname">nibabel.affines.</code><code class="descname">apply_affine</code><span class="sig-paren">(</span><em>aff</em>, <em>pts</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply affine matrix <cite>aff</cite> to points <cite>pts</cite></p>
<p>Returns result of application of <cite>aff</cite> to the <em>right</em> of <cite>pts</cite>.  The
coordinate dimension of <cite>pts</cite> should be the last.</p>
<p>For the 3D case, <cite>aff</cite> will be shape (4,4) and <cite>pts</cite> will have final axis
length 3 - maybe it will just be N by 3. The return value is the
transformed points, in this case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">pts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>This routine is more general than 3D, in that <cite>aff</cite> can have any shape
(N,N), and <cite>pts</cite> can have any shape, as long as the last dimension is for
the coordinates, and is therefore length N-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>aff</strong> : (N, N) array-like</p>
<blockquote>
<div><p>Homogenous affine, for 3D points, will be 4 by 4. Contrary to first
appearance, the affine will be applied on the left of <cite>pts</cite>.</p>
</div></blockquote>
<p><strong>pts</strong> : (..., N-1) array-like</p>
<blockquote>
<div><p>Points, where the last dimension contains the coordinates of each
point.  For 3D, the last dimension will be length 3.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>transformed_pts</strong> : (..., N-1) array</p>
<blockquote class="last">
<div><p>transformed points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">11</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_affine</span><span class="p">(</span><span class="n">aff</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span> 
<span class="go">array([[14, 14, 24],</span>
<span class="go">       [16, 17, 28],</span>
<span class="go">       [20, 23, 36],</span>
<span class="go">       [24, 29, 44]]...)</span>
</pre></div>
</div>
<p>Just to show that in the simple 3D case, it is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">pts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> 
<span class="go">array([[14, 14, 24],</span>
<span class="go">       [16, 17, 28],</span>
<span class="go">       [20, 23, 36],</span>
<span class="go">       [24, 29, 44]]...)</span>
</pre></div>
</div>
<p>But <cite>pts</cite> can be a more complicated shape:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_affine</span><span class="p">(</span><span class="n">aff</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span> 
<span class="go">array([[[14, 14, 24],</span>
<span class="go">        [16, 17, 28]],</span>

<span class="go">       [[20, 23, 36],</span>
<span class="go">        [24, 29, 44]]]...)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dot-reduce">
<h2>dot_reduce<a class="headerlink" href="#dot-reduce" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.affines.dot_reduce">
<code class="descclassname">nibabel.affines.</code><code class="descname">dot_reduce</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.dot_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply numpy dot product function from right to left on arrays</p>
<p>For passed arrays <span class="math">\(A, B, C, ... Z\)</span> returns <span class="math">\(A \dot B \dot C ...
\dot Z\)</span> where &#8221;.&#8221; is the numpy array dot product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**args</strong> : arrays</p>
<blockquote>
<div><p>Arrays that can be passed to numpy <code class="docutils literal"><span class="pre">dot</span></code> function</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dot_product</strong> : array</p>
<blockquote class="last">
<div><p>If there are N arguments, result of <code class="docutils literal"><span class="pre">arg[0].dot(arg[1].dot(arg[2].dot</span>
<span class="pre">...</span>&#160; <span class="pre">arg[N-2].dot(arg[N-1])))...</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="from-matvec">
<h2>from_matvec<a class="headerlink" href="#from-matvec" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.affines.from_matvec">
<code class="descclassname">nibabel.affines.</code><code class="descname">from_matvec</code><span class="sig-paren">(</span><em>matrix</em>, <em>vector=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.from_matvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a matrix and vector into an homogeneous affine</p>
<p>Combine a rotation / scaling / shearing matrix and translation vector into
a transform in homogeneous coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>matrix</strong> : array-like</p>
<blockquote>
<div><p>An NxM array representing the the linear part of the transform.
A transform from an M-dimensional space to an N-dimensional space.</p>
</div></blockquote>
<p><strong>vector</strong> : None or array-like, optional</p>
<blockquote>
<div><p>None or an (N,) array representing the translation. None corresponds to
an (N,) array of zeros.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>xform</strong> : array</p>
<blockquote class="last">
<div><p>An (N+1, M+1) homogenous transform matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nibabel.affines.to_matvec" title="nibabel.affines.to_matvec"><code class="xref py py-obj docutils literal"><span class="pre">to_matvec</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">from_matvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="go">array([[ 2,  0,  0,  9],</span>
<span class="go">       [ 0,  3,  0, 10],</span>
<span class="go">       [ 0,  0,  4, 11],</span>
<span class="go">       [ 0,  0,  0,  1]])</span>
</pre></div>
</div>
<p>The <cite>vector</cite> argument is optional:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">from_matvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">array([[2, 0, 0, 0],</span>
<span class="go">       [0, 3, 0, 0],</span>
<span class="go">       [0, 0, 4, 0],</span>
<span class="go">       [0, 0, 0, 1]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="to-matvec">
<h2>to_matvec<a class="headerlink" href="#to-matvec" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.affines.to_matvec">
<code class="descclassname">nibabel.affines.</code><code class="descname">to_matvec</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.to_matvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a transform into its matrix and vector components.</p>
<p>The tranformation must be represented in homogeneous coordinates and is
split into its rotation matrix and translation vector components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transform</strong> : array-like</p>
<blockquote>
<div><p>NxM transform matrix in homogeneous coordinates representing an affine
transformation from an (N-1)-dimensional space to an (M-1)-dimensional
space. An example is a 4x4 transform representing rotations and
translations in 3 dimensions. A 4x3 matrix can represent a
2-dimensional plane embedded in 3 dimensional space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matrix</strong> : (N-1, M-1) array</p>
<blockquote>
<div><p>Matrix component of <cite>transform</cite></p>
</div></blockquote>
<p><strong>vector</strong> : (M-1,) array</p>
<blockquote class="last">
<div><p>Vector compoent of <cite>transform</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nibabel.affines.from_matvec" title="nibabel.affines.from_matvec"><code class="xref py py-obj docutils literal"><span class="pre">from_matvec</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_matvec</span><span class="p">(</span><span class="n">aff</span><span class="p">)</span>
<span class="go">(array([[2, 0, 0],</span>
<span class="go">       [0, 3, 0],</span>
<span class="go">       [0, 0, 4]]), array([ 9, 10, 11]))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="voxel-sizes">
<h2>voxel_sizes<a class="headerlink" href="#voxel-sizes" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.affines.voxel_sizes">
<code class="descclassname">nibabel.affines.</code><code class="descname">voxel_sizes</code><span class="sig-paren">(</span><em>affine</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.affines.voxel_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return voxel size for each input axis given <cite>affine</cite></p>
<p>The <cite>affine</cite> is the mapping between array (voxel) coordinates and mm
(world) coordinates.</p>
<p>The voxel size for the first voxel (array) axis is the distance moved in
world coordinates when moving one unit along the first voxel (array) axis.
This is the distance between the world coordinate of voxel (0, 0, 0) and
the world coordinate of voxel (1, 0, 0).  The world coordinate vector of
voxel coordinate vector (0, 0, 0) is given by <code class="docutils literal"><span class="pre">v0</span> <span class="pre">=</span> <span class="pre">affine.dot((0,</span> <span class="pre">0,</span> <span class="pre">0,</span>
<span class="pre">1)[:3]</span></code>.  The world coordinate vector of voxel vector (1, 0, 0) is
<code class="docutils literal"><span class="pre">v1_ax1</span> <span class="pre">=</span> <span class="pre">affine.dot((1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1))[:3]</span></code>.  The final 1 in the voxel
vectors and the <code class="docutils literal"><span class="pre">[:3]</span></code> at the end are because the affine works on
homogenous coodinates.  The translations part of the affine is <code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span>
<span class="pre">affine[:3,</span> <span class="pre">3]</span></code>, and the rotations, zooms and shearing part of the affine
is <code class="docutils literal"><span class="pre">rzs</span> <span class="pre">=</span> <span class="pre">affine[:3,</span> <span class="pre">:3]</span></code>. Because of the final 1 in the input voxel
vector, <code class="docutils literal"><span class="pre">v0</span> <span class="pre">==</span> <span class="pre">rzs.dot((0,</span> <span class="pre">0,</span> <span class="pre">0))</span> <span class="pre">+</span> <span class="pre">trans</span></code>, and <code class="docutils literal"><span class="pre">v1_ax1</span> <span class="pre">==</span> <span class="pre">rzs.dot((1,</span>
<span class="pre">0,</span> <span class="pre">0))</span> <span class="pre">+</span> <span class="pre">trans</span></code>, and the difference vector is <code class="docutils literal"><span class="pre">rzs.dot((0,</span> <span class="pre">0,</span> <span class="pre">0))</span> <span class="pre">-</span>
<span class="pre">rzs.dot((1,</span> <span class="pre">0,</span> <span class="pre">0))</span> <span class="pre">==</span> <span class="pre">rzs.dot((1,</span> <span class="pre">0,</span> <span class="pre">0))</span> <span class="pre">==</span> <span class="pre">rzs[:,</span> <span class="pre">0]</span></code>.  The distance
vectors in world coordinates between (0, 0, 0) and (1, 0, 0), (0, 1, 0),
(0, 0, 1) are given by <code class="docutils literal"><span class="pre">rzs.dot(np.eye(3))</span> <span class="pre">=</span> <span class="pre">rzs</span></code>.  The voxel sizes are
the Euclidean lengths of the distance vectors.  So, the voxel sizes are
the Euclidean lengths of the columns of the affine (excluding the last row
and column of the affine).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>affine</strong> : 2D array-like</p>
<blockquote>
<div><p>Affine transformation array.  Usually shape (4, 4), but can be any 2D
array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vox_sizes</strong> : 1D array</p>
<blockquote class="last">
<div><p>Voxel sizes for each input axis of affine.  Usually 1D array length 3,
but in general has length (N-1) where input <cite>affine</cite> is shape (M, N).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2016, Matthew Brett, Michael Hanke, Eric Larson, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>