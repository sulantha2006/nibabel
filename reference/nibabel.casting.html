<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &#8212; NiBabel 2.1.1dev documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.1.1dev documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="data" href="nibabel.data.html" />
    <link rel="prev" title="arraywriters" href="nibabel.arraywriters.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.data.html" title="data"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.arraywriters.html" title="arraywriters"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">casting</span></code></a><ul>
<li><a class="reference internal" href="#castingerror"><code class="docutils literal"><span class="pre">CastingError</span></code></a></li>
<li><a class="reference internal" href="#floatingerror"><code class="docutils literal"><span class="pre">FloatingError</span></code></a></li>
<li><a class="reference internal" href="#able-int-type">able_int_type</a></li>
<li><a class="reference internal" href="#as-int">as_int</a></li>
<li><a class="reference internal" href="#best-float">best_float</a></li>
<li><a class="reference internal" href="#ceil-exact">ceil_exact</a></li>
<li><a class="reference internal" href="#float-to-int">float_to_int</a></li>
<li><a class="reference internal" href="#floor-exact">floor_exact</a></li>
<li><a class="reference internal" href="#floor-log2">floor_log2</a></li>
<li><a class="reference internal" href="#have-binary128">have_binary128</a></li>
<li><a class="reference internal" href="#int-abs">int_abs</a></li>
<li><a class="reference internal" href="#int-to-float">int_to_float</a></li>
<li><a class="reference internal" href="#longdouble-lte-float64">longdouble_lte_float64</a></li>
<li><a class="reference internal" href="#longdouble-precision-improved">longdouble_precision_improved</a></li>
<li><a class="reference internal" href="#ok-floats">ok_floats</a></li>
<li><a class="reference internal" href="#on-powerpc">on_powerpc</a></li>
<li><a class="reference internal" href="#shared-range">shared_range</a></li>
<li><a class="reference internal" href="#type-info">type_info</a></li>
<li><a class="reference internal" href="#ulp">ulp</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.arraywriters.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">arraywriters</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.data.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">data</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.casting.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.casting">
<span id="casting"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">casting</span></code><a class="headerlink" href="#module-nibabel.casting" title="Permalink to this headline">¶</a></h1>
<p>Utilties for casting numpy values in various ways</p>
<p>Most routines work round some numpy oddities in floating point precision and
casting.  Others work round numpy casting to and from python ints</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.CastingError" title="nibabel.casting.CastingError"><code class="xref py py-obj docutils literal"><span class="pre">CastingError</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.FloatingError" title="nibabel.casting.FloatingError"><code class="xref py py-obj docutils literal"><span class="pre">FloatingError</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.able_int_type" title="nibabel.casting.able_int_type"><code class="xref py py-obj docutils literal"><span class="pre">able_int_type</span></code></a>(values)</td>
<td>Find the smallest integer numpy type to contain sequence <cite>values</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.as_int" title="nibabel.casting.as_int"><code class="xref py py-obj docutils literal"><span class="pre">as_int</span></code></a>(x[,&nbsp;check])</td>
<td>Return python integer representation of number</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.best_float" title="nibabel.casting.best_float"><code class="xref py py-obj docutils literal"><span class="pre">best_float</span></code></a>()</td>
<td>Floating point type with best precision</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.ceil_exact" title="nibabel.casting.ceil_exact"><code class="xref py py-obj docutils literal"><span class="pre">ceil_exact</span></code></a>(val,&nbsp;flt_type)</td>
<td>Return nearest exact integer &gt;= <cite>val</cite> in float type <cite>flt_type</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.float_to_int" title="nibabel.casting.float_to_int"><code class="xref py py-obj docutils literal"><span class="pre">float_to_int</span></code></a>(arr,&nbsp;int_type[,&nbsp;nan2zero,&nbsp;infmax])</td>
<td>Convert floating point array <cite>arr</cite> to type <cite>int_type</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.floor_exact" title="nibabel.casting.floor_exact"><code class="xref py py-obj docutils literal"><span class="pre">floor_exact</span></code></a>(val,&nbsp;flt_type)</td>
<td>Return nearest exact integer &lt;= <cite>val</cite> in float type <cite>flt_type</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.floor_log2" title="nibabel.casting.floor_log2"><code class="xref py py-obj docutils literal"><span class="pre">floor_log2</span></code></a>(x)</td>
<td>floor of log2 of abs(<cite>x</cite>)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.have_binary128" title="nibabel.casting.have_binary128"><code class="xref py py-obj docutils literal"><span class="pre">have_binary128</span></code></a>()</td>
<td>True if we have a binary128 IEEE longdouble</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.int_abs" title="nibabel.casting.int_abs"><code class="xref py py-obj docutils literal"><span class="pre">int_abs</span></code></a>(arr)</td>
<td>Absolute values of array taking care of max negative int values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.int_to_float" title="nibabel.casting.int_to_float"><code class="xref py py-obj docutils literal"><span class="pre">int_to_float</span></code></a>(val,&nbsp;flt_type)</td>
<td>Convert integer <cite>val</cite> to floating point type <cite>flt_type</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.longdouble_lte_float64" title="nibabel.casting.longdouble_lte_float64"><code class="xref py py-obj docutils literal"><span class="pre">longdouble_lte_float64</span></code></a>()</td>
<td>Return True if longdouble appears to have the same precision as float64</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.longdouble_precision_improved" title="nibabel.casting.longdouble_precision_improved"><code class="xref py py-obj docutils literal"><span class="pre">longdouble_precision_improved</span></code></a>()</td>
<td>True if longdouble precision increased since initial import</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.ok_floats" title="nibabel.casting.ok_floats"><code class="xref py py-obj docutils literal"><span class="pre">ok_floats</span></code></a>()</td>
<td>Return floating point types sorted by precision</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.on_powerpc" title="nibabel.casting.on_powerpc"><code class="xref py py-obj docutils literal"><span class="pre">on_powerpc</span></code></a>()</td>
<td>True if we are running on a Power PC platform</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.shared_range" title="nibabel.casting.shared_range"><code class="xref py py-obj docutils literal"><span class="pre">shared_range</span></code></a>(flt_type,&nbsp;int_type)</td>
<td>Min and max in float type that are &gt;=min, &lt;=max in integer type</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.casting.type_info" title="nibabel.casting.type_info"><code class="xref py py-obj docutils literal"><span class="pre">type_info</span></code></a>(np_type)</td>
<td>Return dict with min, max, nexp, nmant, width for numpy type <cite>np_type</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.casting.ulp" title="nibabel.casting.ulp"><code class="xref py py-obj docutils literal"><span class="pre">ulp</span></code></a>([val])</td>
<td>Return gap between <cite>val</cite> and nearest representable number of same type</td>
</tr>
</tbody>
</table>
<div class="section" id="castingerror">
<h2><a class="reference internal" href="#nibabel.casting.CastingError" title="nibabel.casting.CastingError"><code class="xref py py-class docutils literal"><span class="pre">CastingError</span></code></a><a class="headerlink" href="#castingerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.casting.CastingError">
<em class="property">class </em><code class="descclassname">nibabel.casting.</code><code class="descname">CastingError</code><a class="headerlink" href="#nibabel.casting.CastingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<dl class="method">
<dt id="nibabel.casting.CastingError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.CastingError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="floatingerror">
<h2><a class="reference internal" href="#nibabel.casting.FloatingError" title="nibabel.casting.FloatingError"><code class="xref py py-class docutils literal"><span class="pre">FloatingError</span></code></a><a class="headerlink" href="#floatingerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.casting.FloatingError">
<em class="property">class </em><code class="descclassname">nibabel.casting.</code><code class="descname">FloatingError</code><a class="headerlink" href="#nibabel.casting.FloatingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<dl class="method">
<dt id="nibabel.casting.FloatingError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.FloatingError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="able-int-type">
<h2>able_int_type<a class="headerlink" href="#able-int-type" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.able_int_type">
<code class="descclassname">nibabel.casting.</code><code class="descname">able_int_type</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.able_int_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the smallest integer numpy type to contain sequence <cite>values</cite></p>
<p>Prefers uint to int if minimum is &gt;= 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>values</strong> : sequence</p>
<blockquote>
<div><p>sequence of integer values</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>itype</strong> : None or numpy type</p>
<blockquote class="last">
<div><p>numpy integer type or None if no integer type holds all <cite>values</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">able_int_type</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">able_int_type</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="as-int">
<h2>as_int<a class="headerlink" href="#as-int" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.as_int">
<code class="descclassname">nibabel.casting.</code><code class="descname">as_int</code><span class="sig-paren">(</span><em>x</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.as_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Return python integer representation of number</p>
<p>This is useful because the numpy int(val) mechanism is broken for large
values in np.longdouble.</p>
<p>It is also useful to work around a numpy 1.4.1 bug in conversion of uints
to python ints.</p>
<p>This routine will still raise an OverflowError for values that are outside
the range of float64.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : object</p>
<blockquote>
<div><p>integer, unsigned integer or floating point value</p>
</div></blockquote>
<p><strong>check</strong> : {True, False}</p>
<blockquote>
<div><p>If True, raise error for values that are not integers</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>i</strong> : int</p>
<blockquote class="last">
<div><p>Python integer</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">as_int</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">as_int</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">as_int</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">FloatingError</span>: <span class="n">Not an integer: 2.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">as_int</span><span class="p">(</span><span class="mf">2.1</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="best-float">
<h2>best_float<a class="headerlink" href="#best-float" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.best_float">
<code class="descclassname">nibabel.casting.</code><code class="descname">best_float</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.best_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Floating point type with best precision</p>
<p>This is nearly always np.longdouble, except on Windows, where np.longdouble
is Intel80 storage, but with float64 precision for calculations.  In that
case we return float64 on the basis it&#8217;s the fastest and smallest at the
highest precision.</p>
<p>SPARC float128 also proved so slow that we prefer float64.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>best_type</strong> : numpy type</p>
<blockquote class="last">
<div><p>floating point type with highest precision</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Needs to run without error for module import, because it is called in
<code class="docutils literal"><span class="pre">ok_floats</span></code> below, and therefore in setting module global <code class="docutils literal"><span class="pre">OK_FLOATS</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="ceil-exact">
<h2>ceil_exact<a class="headerlink" href="#ceil-exact" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.ceil_exact">
<code class="descclassname">nibabel.casting.</code><code class="descname">ceil_exact</code><span class="sig-paren">(</span><em>val</em>, <em>flt_type</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.ceil_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nearest exact integer &gt;= <cite>val</cite> in float type <cite>flt_type</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : int</p>
<blockquote>
<div><p>We have to pass val as an int rather than the floating point type
because large integers cast as floating point may be rounded by the
casting process.</p>
</div></blockquote>
<p><strong>flt_type</strong> : numpy type</p>
<blockquote>
<div><p>numpy float type.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ceil_val</strong> : object</p>
<blockquote class="last">
<div><p>value of same floating point type as <cite>val</cite>, that is the nearest exact
integer in this type such that <cite>floor_val</cite> &gt;= <cite>val</cite>.  Thus if <cite>val</cite> is
exact in <cite>flt_type</cite>, <cite>ceil_val</cite> == <cite>val</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Obviously 2 is within the range of representable integers for float32</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ceil_exact</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>As is 2**24-1 (the number of significand digits is 23 + 1 implicit)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ceil_exact</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But 2**24+1 gives a number that float32 can&#8217;t represent exactly</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ceil_exact</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">+</span><span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As for the numpy ceil function, negatives ceil towards inf</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ceil_exact</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="float-to-int">
<h2>float_to_int<a class="headerlink" href="#float-to-int" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.float_to_int">
<code class="descclassname">nibabel.casting.</code><code class="descname">float_to_int</code><span class="sig-paren">(</span><em>arr</em>, <em>int_type</em>, <em>nan2zero=True</em>, <em>infmax=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.float_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert floating point array <cite>arr</cite> to type <cite>int_type</cite></p>
<ul class="simple">
<li>Rounds numbers to nearest integer</li>
<li>Clips values to prevent overflows when casting</li>
<li>Converts NaN to 0 (for <cite>nan2zero</cite> == True)</li>
</ul>
<p>Casting floats to integers is delicate because the result is undefined
and platform specific for float values outside the range of <cite>int_type</cite>.
Define <code class="docutils literal"><span class="pre">shared_min</span></code> to be the minimum value that can be exactly
represented in both the float type of <cite>arr</cite> and <cite>int_type</cite>. Define
<cite>shared_max</cite> to be the equivalent maximum value.  To avoid undefined
results we threshold <cite>arr</cite> at <code class="docutils literal"><span class="pre">shared_min</span></code> and <code class="docutils literal"><span class="pre">shared_max</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : array-like</p>
<blockquote>
<div><p>Array of floating point type</p>
</div></blockquote>
<p><strong>int_type</strong> : object</p>
<blockquote>
<div><p>Numpy integer type</p>
</div></blockquote>
<p><strong>nan2zero</strong> : {True, False, None}</p>
<blockquote>
<div><p>Whether to convert NaN value to zero.  Default is True.  If False, and
NaNs are present, raise CastingError. If None, do not check for NaN
values and pass through directly to the <code class="docutils literal"><span class="pre">astype</span></code> casting mechanism.
In this last case, the resulting value is undefined.</p>
</div></blockquote>
<p><strong>infmax</strong> : {False, True}</p>
<blockquote>
<div><p>If True, set np.inf values in <cite>arr</cite> to be <cite>int_type</cite> integer maximum
value, -np.inf as <cite>int_type</cite> integer minimum.  If False, set +/- infs
to be <code class="docutils literal"><span class="pre">shared_min</span></code>, <code class="docutils literal"><span class="pre">shared_max</span></code> as defined above.  Therefore False
gives faster conversion at the expense of infs that are further from
infinity.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>iarr</strong> : ndarray</p>
<blockquote class="last">
<div><p>of type <cite>int_type</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Numpy relies on the C library to cast from float to int using the standard
<code class="docutils literal"><span class="pre">astype</span></code> method of the array.</p>
<p>Quoting from section F4 of the C99 standard:</p>
<blockquote>
<div>If the floating value is infinite or NaN or if the integral part of the
floating value exceeds the range of the integer type, then the
&#8220;invalid&#8221; floating-point exception is raised and the resulting value
is unspecified.</div></blockquote>
<p>Hence we threshold at <code class="docutils literal"><span class="pre">shared_min</span></code> and <code class="docutils literal"><span class="pre">shared_max</span></code> to avoid casting to
values that are undefined.</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/C99">https://en.wikipedia.org/wiki/C99</a> . There are links to the C99
standard from that page.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">float_to_int</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="go">array([     0,  32767, -32768,      1,      7], dtype=int16)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="floor-exact">
<h2>floor_exact<a class="headerlink" href="#floor-exact" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.floor_exact">
<code class="descclassname">nibabel.casting.</code><code class="descname">floor_exact</code><span class="sig-paren">(</span><em>val</em>, <em>flt_type</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.floor_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nearest exact integer &lt;= <cite>val</cite> in float type <cite>flt_type</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : int</p>
<blockquote>
<div><p>We have to pass val as an int rather than the floating point type
because large integers cast as floating point may be rounded by the
casting process.</p>
</div></blockquote>
<p><strong>flt_type</strong> : numpy type</p>
<blockquote>
<div><p>numpy float type.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>floor_val</strong> : object</p>
<blockquote class="last">
<div><p>value of same floating point type as <cite>val</cite>, that is the nearest exact
integer in this type such that <cite>floor_val</cite> &lt;= <cite>val</cite>.  Thus if <cite>val</cite> is
exact in <cite>flt_type</cite>, <cite>floor_val</cite> == <cite>val</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Obviously 2 is within the range of representable integers for float32</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floor_exact</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>As is 2**24-1 (the number of significand digits is 23 + 1 implicit)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floor_exact</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But 2**24+1 gives a number that float32 can&#8217;t represent exactly</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floor_exact</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As for the numpy floor function, negatives floor towards -inf</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floor_exact</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="o">-</span><span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="floor-log2">
<h2>floor_log2<a class="headerlink" href="#floor-log2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.floor_log2">
<code class="descclassname">nibabel.casting.</code><code class="descname">floor_log2</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.floor_log2" title="Permalink to this definition">¶</a></dt>
<dd><p>floor of log2 of abs(<cite>x</cite>)</p>
<p>Embarrassingly, from <a class="reference external" href="https://en.wikipedia.org/wiki/Binary_logarithm">https://en.wikipedia.org/wiki/Binary_logarithm</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>L</strong> : None or int</p>
<blockquote class="last">
<div><p>floor of base 2 log of <cite>x</cite>.  None if <cite>x</cite> == 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floor_log2</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">9</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">floor_log2</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">9</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">floor_log2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">floor_log2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="have-binary128">
<h2>have_binary128<a class="headerlink" href="#have-binary128" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.have_binary128">
<code class="descclassname">nibabel.casting.</code><code class="descname">have_binary128</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.have_binary128" title="Permalink to this definition">¶</a></dt>
<dd><p>True if we have a binary128 IEEE longdouble</p>
</dd></dl>

</div>
<div class="section" id="int-abs">
<h2>int_abs<a class="headerlink" href="#int-abs" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.int_abs">
<code class="descclassname">nibabel.casting.</code><code class="descname">int_abs</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.int_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute values of array taking care of max negative int values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : array-like</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>abs_arr</strong> : array</p>
<blockquote class="last">
<div><p>array the same shape as <cite>arr</cite> in which all negative numbers have been
changed to positive numbers with the magnitude.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This kind of thing is confusing in base numpy:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">))</span>
<span class="go">-128</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">int_abs</span></code> fixes that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">int_abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">))</span>
<span class="go">128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">127</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">))</span>
<span class="go">array([128, 127], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">127</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="go">array([ 128.,  127.], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="int-to-float">
<h2>int_to_float<a class="headerlink" href="#int-to-float" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.int_to_float">
<code class="descclassname">nibabel.casting.</code><code class="descname">int_to_float</code><span class="sig-paren">(</span><em>val</em>, <em>flt_type</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.int_to_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert integer <cite>val</cite> to floating point type <cite>flt_type</cite></p>
<p>Why is this so complicated?</p>
<p>At least in numpy &lt;= 1.6.1, numpy longdoubles do not correctly convert to
ints, and ints do not correctly convert to longdoubles.  Specifically, in
both cases, the values seem to go through float64 conversion on the way, so
to convert better, we need to split into float64s and sum up the result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : int</p>
<blockquote>
<div><p>Integer value</p>
</div></blockquote>
<p><strong>flt_type</strong> : object</p>
<blockquote>
<div><p>numpy floating point type</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : numpy scalar</p>
<blockquote class="last">
<div><p>of type <cite>flt_type</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="longdouble-lte-float64">
<h2>longdouble_lte_float64<a class="headerlink" href="#longdouble-lte-float64" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.longdouble_lte_float64">
<code class="descclassname">nibabel.casting.</code><code class="descname">longdouble_lte_float64</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.longdouble_lte_float64" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if longdouble appears to have the same precision as float64</p>
</dd></dl>

</div>
<div class="section" id="longdouble-precision-improved">
<h2>longdouble_precision_improved<a class="headerlink" href="#longdouble-precision-improved" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.longdouble_precision_improved">
<code class="descclassname">nibabel.casting.</code><code class="descname">longdouble_precision_improved</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.longdouble_precision_improved" title="Permalink to this definition">¶</a></dt>
<dd><p>True if longdouble precision increased since initial import</p>
<p>This can happen on Windows compiled with MSVC.  It may be because libraries
compiled with mingw (longdouble is Intel80) get linked to numpy compiled
with MSVC (longdouble is Float64)</p>
</dd></dl>

</div>
<div class="section" id="ok-floats">
<h2>ok_floats<a class="headerlink" href="#ok-floats" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.ok_floats">
<code class="descclassname">nibabel.casting.</code><code class="descname">ok_floats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.ok_floats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return floating point types sorted by precision</p>
<p>Remove longdouble if it has no higher precision than float64</p>
</dd></dl>

</div>
<div class="section" id="on-powerpc">
<h2>on_powerpc<a class="headerlink" href="#on-powerpc" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.on_powerpc">
<code class="descclassname">nibabel.casting.</code><code class="descname">on_powerpc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.on_powerpc" title="Permalink to this definition">¶</a></dt>
<dd><p>True if we are running on a Power PC platform</p>
<p>Has to deal with older Macs and IBM POWER7 series among others</p>
</dd></dl>

</div>
<div class="section" id="shared-range">
<h2>shared_range<a class="headerlink" href="#shared-range" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.shared_range">
<code class="descclassname">nibabel.casting.</code><code class="descname">shared_range</code><span class="sig-paren">(</span><em>flt_type</em>, <em>int_type</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.shared_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Min and max in float type that are &gt;=min, &lt;=max in integer type</p>
<p>This is not as easy as it sounds, because the float type may not be able to
exactly represent the max or min integer values, so we have to find the
next exactly representable floating point value to do the thresholding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>flt_type</strong> : dtype specifier</p>
<blockquote>
<div><p>A dtype specifier referring to a numpy floating point type.  For
example, <code class="docutils literal"><span class="pre">f4</span></code>, <code class="docutils literal"><span class="pre">np.dtype('f4')</span></code>, <code class="docutils literal"><span class="pre">np.float32</span></code> are equivalent.</p>
</div></blockquote>
<p><strong>int_type</strong> : dtype specifier</p>
<blockquote>
<div><p>A dtype specifier referring to a numpy integer type.  For example,
<code class="docutils literal"><span class="pre">i4</span></code>, <code class="docutils literal"><span class="pre">np.dtype('i4')</span></code>, <code class="docutils literal"><span class="pre">np.int32</span></code> are equivalent</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mn</strong> : object</p>
<blockquote>
<div><p>Number of type <cite>flt_type</cite> that is the minumum value in the range of
<cite>int_type</cite>, such that <code class="docutils literal"><span class="pre">mn.astype(int_type)</span></code> &gt;= min of <cite>int_type</cite></p>
</div></blockquote>
<p><strong>mx</strong> : object</p>
<blockquote class="last">
<div><p>Number of type <cite>flt_type</cite> that is the maximum value in the range of
<cite>int_type</cite>, such that <code class="docutils literal"><span class="pre">mx.astype(int_type)</span></code> &lt;= max of <cite>int_type</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shared_range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mf">2147483648.0</span><span class="p">,</span> <span class="mf">2147483520.0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shared_range</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mf">2147483648.0</span><span class="p">,</span> <span class="mf">2147483520.0</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="type-info">
<h2>type_info<a class="headerlink" href="#type-info" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.type_info">
<code class="descclassname">nibabel.casting.</code><code class="descname">type_info</code><span class="sig-paren">(</span><em>np_type</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.type_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dict with min, max, nexp, nmant, width for numpy type <cite>np_type</cite></p>
<p>Type can be integer in which case nexp and nmant are None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>np_type</strong> : numpy type specifier</p>
<blockquote>
<div><p>Any specifier for a numpy dtype</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>info</strong> : dict</p>
<blockquote>
<div><p>with fields <code class="docutils literal"><span class="pre">min</span></code> (minimum value), <code class="docutils literal"><span class="pre">max</span></code> (maximum value), <code class="docutils literal"><span class="pre">nexp</span></code>
(exponent width), <code class="docutils literal"><span class="pre">nmant</span></code> (significand precision not including
implicit first digit), <code class="docutils literal"><span class="pre">minexp</span></code> (minimum exponent), <code class="docutils literal"><span class="pre">maxexp</span></code>
(maximum exponent), <code class="docutils literal"><span class="pre">width</span></code> (width in bytes). (<code class="docutils literal"><span class="pre">nexp</span></code>, <code class="docutils literal"><span class="pre">nmant</span></code>,
<code class="docutils literal"><span class="pre">minexp</span></code>, <code class="docutils literal"><span class="pre">maxexp</span></code>) are None for integer types. Both <code class="docutils literal"><span class="pre">min</span></code> and
<code class="docutils literal"><span class="pre">max</span></code> are of type <cite>np_type</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>FloatingError</strong></p>
<blockquote class="last">
<div><p>for floating point types we don&#8217;t recognize</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>You might be thinking that <code class="docutils literal"><span class="pre">np.finfo</span></code> does this job, and it does, except
for PPC long doubles (<a class="reference external" href="https://github.com/numpy/numpy/issues/2669">https://github.com/numpy/numpy/issues/2669</a>) and
float96 on Windows compiled with Mingw. This routine protects against such
errors in <code class="docutils literal"><span class="pre">np.finfo</span></code> by only accepting values that we know are likely to
be correct.</p>
</dd></dl>

</div>
<div class="section" id="ulp">
<h2>ulp<a class="headerlink" href="#ulp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.casting.ulp">
<code class="descclassname">nibabel.casting.</code><code class="descname">ulp</code><span class="sig-paren">(</span><em>val=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.casting.ulp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return gap between <cite>val</cite> and nearest representable number of same type</p>
<p>This is the value of a unit in the last place (ULP), and is similar in
meaning to the MATLAB eps function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : scalar, optional</p>
<blockquote>
<div><p>scalar value of any numpy type.  Default is 1.0 (float64)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ulp_val</strong> : scalar</p>
<blockquote class="last">
<div><p>gap between <cite>val</cite> and nearest representable number of same type</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The wikipedia article on machine epsilon points out that the term <em>epsilon</em>
can be used in the sense of a unit in the last place (ULP), or as the
maximum relative rounding error.  The MATLAB <code class="docutils literal"><span class="pre">eps</span></code> function uses the ULP
meaning, but this function is <code class="docutils literal"><span class="pre">ulp</span></code> rather than <code class="docutils literal"><span class="pre">eps</span></code> to avoid
confusion between different meanings of <em>eps</em>.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2016, Matthew Brett, Michael Hanke, Eric Larson, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>